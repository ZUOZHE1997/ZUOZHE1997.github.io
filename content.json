{"pages":[{"title":"","text":"12345678910{ &quot;Name&quot;: &quot;LiuLin&quot;, &quot;Age&quot;: 23, &quot;Job&quot;: &quot;Front-end develospert&quot;, &quot;Will use&quot;: &quot;Html,Css,JavaScript,Golang&quot;, &quot;Web framework&quot;: &quot;Vue,React&quot;, &quot;School&quot;: &quot;Yantai university&quot;, &quot;Phone&quot;: &quot;15624121063&quot;, &quot;mail&quot;: &quot;iamacooldog@foxmail.com&quot;}","link":"/about/details.html"},{"title":"","text":"Hi 👋, I'm LiuLin A passionate frontend developer from China 🌱 I’m currently learning React,Node 📝 I regularly write articles on zuozhe1997.github.io 💬 Ask me about Vue or JavaScript ⚡ Fun fact I think i am funny Languages and Tools: 我的简历","link":"/about/index.html"},{"title":"","text":"个人信息 刘琳/男/1997 工作年限：2 年 技术博客：https://zuozhe1997.github.io/ Github：http://github.com/zuozhe1997 期望职位：前端开发工程师 期望城市: 北京 联系方式 手机：15624121063 Email：iamliulinin1997@qq.com 微信号:15624121063 技能清单 熟悉 HTML,CSS,ES5、ES6 标准的 JavaScript,熟悉 Scss,Stylus 等 CSS 预处理语言 熟悉模块化、前端编译和构建工具,熟练运用前端主流框架 Vue,其他框架熟悉如 React 等 熟练掌握 Vue 生态常用工具 vue-router/Vuex/Axios 等,并能够熟练的使用如 Element-ui 等的 UI 组件库 了解 node.js，利用其搭建简单的服务器 熟练使用 Git 版本控制工具，进行代码管理，实现敏捷开发 工作经历蜗蜗智能科技有限公司 （ 2020 年 9 月 ~ 至今）负责现有的管理平台，运营平台的维护与版本迭代,以及组件库的完善与开发,持续改进前端页面设计平台，通过开发工具、改进流程，保证前端业务开发的高效性。 山东趣深网络科技有限公司 （ 2019 年 3 月 ~ 2020 年 8 月）暖虎公寓租赁平台 简介:一个类似蘑菇租房的管理员端项目 职责: 负责项目整个前端页面的代码编写,根据业务继续封装常用的组件,根据业务完善快速开发框架的权限职责管理,与后端配合完成 API 的调试,最后与产品经理保持沟通，对订单管理模块进行维护与高效重构 趣考试-高校版 简介: 一个在线考试平台,分为学生端与教师端,考试通过视频监考 职责: 独自负责项目从无到有的研发,用一个月的时间独立开发了初版的项目,集成了防作弊,实时监考,视频认证等功能。负责后期将考试模块集成到教育平台上。 趣深企业教育平台 简介: 面向企业的教育平台,实现在线学习,在线问卷调查,在线发布知识点等模块 职责: 基于原有项目用 Vue 进行重构,着手搭建框架快速开发框架,基于 Axios 进行 API 的封装,并能根据业务需求,封装高复用和可维护性好的前端组件,并试着学习开始从用户的角度出发,完整整个产品的功能优化 教育2016-2019 山东科技职业学院 信息工程系2019-2022 烟台大学 计算机控制与工程学院","link":"/about/resume.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2021计划","text":"去年时写的 19 年总结还有最后一个任务没有完成,那就是去一趟重庆吃火锅哈哈哈去年经历过的事情实在是太多了,一月份正好是个新的开始哈哈2021 计划 去一趟重庆吃火锅 继续学习 React,react-router,redux 学习 Docker,Nginx,Linux,以及 mysql 学习 Golang,以及 Gin 框架,在学习一个爬虫框架 等 Vue3 正式版本更新再看一下 攒钱,开始理财 减肥 如果上面这些任务全部完成就奖励自己一台 MacBook pro 吧哈哈哈","link":"/2021/01/13/life/2021%E8%AE%A1%E5%88%92/"},{"title":"19总结","text":"写了一些废话又删除了,像是流水账一般,才反应过来差不多该简练一点哈哈哈 19 年开始做前端19 年回顾了 Html,Css,Js,又进一步学习了 Vue 和 Uniapp,这一年写过 web 端,也写过小程序哈啊哈哈哈等快到年底了才开始继续学 ES6,Sass 的一些知识哈哈哈争取 2020 年把&lt;JavaScript 高程&gt;看完吧 接下来的计划 攒钱,去一趟重庆,走一趟大西北环形路线(大西北是真的神奇,太吸引人了) 技术提升,20 年争取把基础打好,ES6,配置 Webpack,试着看下 Vue 的原理,在着也可 以了解下 React,可以自己造几个轮子用用 生活,学会做菜 早睡早起,锻炼身体 减肥,开始跑步 看书,继续之前的书单 找一个爱好 让我们加油吧,一切都会变好的(其实到了 2020 年底我又重新看了眼我的计划,除了出去玩全部都完成了哈哈哈哈)","link":"/2019/12/29/life/2020%E5%B9%B4%E8%AE%A1%E5%88%92/"},{"title":"🍤JavaScript错误处理","text":"JavaScript 错误处理语句 try 语句测试代码块的错误。 catch 语句处理错误。 throw 语句创建自定义错误。 finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188//try语句通常搭配catch语句来使用try {...}catch{...}//比如try{console.logg(123)//程序会在这里停止执行}catch{console.log(321)//在上一句抛出异常后会执行 catch 中的语句,此时输出 321} //321//或者后面常常也会配合 finally 一起使用try {...}catch{...} finally{...}//比如try{console.logg(123)//程序会在这里停止执行}catch{console.log(321)//在上一句抛出异常后会执行 catch 中的语句,此时输出 321}finally{console.log(456)} //321 //456throw 语句throw 语句允许我们创建自定义错误。正确的技术术语是：创建或抛出异常（exception）。//比如throw hello有时,try...catch...语句也会和throw语句一起使用let a= 12try{ if(a===&quot;&quot;) throw &quot;值为空&quot; if(isNaN(a)) throw &quot;不是数字&quot;; a = Number(a);if(a&gt;10) throw &quot;这个数字比10大&quot; if (a&lt;10) throw &quot;这个数字比10小&quot;} catch(err){console.log(err)} //没有catch语句时,程序会中断,先执行finally语句,然后再抛出异常信息 function cleansUp() { try { throw new Error('出错了……'); console.log('此行不会执行'); } finally { console.log('完成清理工作'); }}cleansUp()// 完成清理工作// Uncaught Error: 出错了……// at cleansUp (&lt;anonymous&gt;:3:11)// at &lt;anonymous&gt;:10:1 function idle(x) { try { console.log(x); return 'result'; } finally { console.log('FINALLY'); }}idle('hello')// hello// FINALLY上面代码中，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。而且，这个函数的返回值还是result。下面的例子说明，return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。var count = 0;function countUp() { try { return count; } finally { count++; }}countUp()// 0count// 1上面代码说明，return语句里面的count的值，是在finally代码块运行之前就获取了。下面是finally代码块用法的典型场景。openFile();try { writeFile(Data);} catch(e) { handleError(e);} finally { closeFile();}上面代码首先打开一个文件，然后在try代码块中写入文件，如果没有发生错误，则运行finally代码块关闭文件；一旦发生错误，则先使用catch代码块处理错误，再使用finally代码块关闭文件。下面的例子充分反映了try...catch...finally这三者之间的执行顺序。function f() { try { console.log(0); throw 'bug'; } catch(e) { console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 } finally { console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 } console.log(5); // 不会运行}var result = f();// 0// 1// 3result// false上面代码中，catch代码块结束执行之前，会先执行finally代码块。catch代码块之中，触发转入finally代码块的标志，不仅有return语句，还有throw语句。function f() { try { throw '出错了！'; } catch(e) { console.log('捕捉到内部错误'); throw e; // 这句原本会等到finally结束再执行 } finally { return false; // 直接返回 }}try { f();} catch(e) { // 此处不会执行 console.log('caught outer &quot;bogus&quot;');}// 捕捉到内部错误上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。try代码块内部，还可以再使用try代码块。try { try { consle.log('Hello world!'); // 报错 } finally { console.log('Finally'); } console.log('Will I run?');} catch(error) { console.error(error.message);}// Finally// consle is not defined上面代码中，try里面还有一个try。内层的try报错（console拼错了），这时会执行内层的finally代码块，然后抛出错误，被外层的catch捕获。 JavaScript 原生错误类型 1.SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。 1234567// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log 'hello');// Uncaught SyntaxError: Unexpected string 上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出SyntaxError。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。 2.ReferenceError 对象ReferenceError对象是引用一个不存在的变量时发生的错误。 123// 使用一个不存在的变量unknownVariable;// Uncaught ReferenceError: unknownVariable is not defined 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。 123// 等号左侧不是变量console.log() = 1// Uncaught ReferenceError: Invalid left-hand side in assignment 上面代码对函数console.log的运行结果赋值，结果引发了ReferenceError错误。 3.RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。 1234567// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length 函数堆栈超过最大值 4.TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 123456new 123// Uncaught TypeError: number is not a funcvar obj = {};obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function 上面代码的第二种情况，调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。 5.URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 12decodeURI(&quot;%2&quot;);// URIError: URI malformed 6.EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。","link":"/2019/07/11/notes/2019/JavaScript%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%F0%9F%99%85/"},{"title":"🍢vue生命周期函数","text":"介绍 vue 实例的生命周期：从 Vue 实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期。 生命周期钩子：就是生命周期事件的别名而已。 生命周期钩子 = 生命周期函数 = 生命周期事件。 生命周期函数的主要分类根据上面这张图，我们把生命周期函数主要分为三类。 1、创建期间的生命周期函数 - beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建 OK，此时 data 和 methods 已经创建 OK，此时还没有开始 编译模板。我们可以在这里进行 Ajax 请求。 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示。（mounted 之后，表示真实 DOM 渲染完了，可以操作 DOM 了） 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--这个div区域就是MVVM中的 View--&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data: { msg: &quot;hello vuejs&quot;, }, // 这是第1个生命周期函数，表示实例完全被创建出来之前，会执行它 beforeCreate: function () { console.log(&quot;01 beforeCreate&quot;, this.msg); //注意：在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 }, // 这是第2个生命周期函数 created: function () { console.log(&quot;02 created&quot;, this.msg); //注意：如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 }, // 这是第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中 beforeMount: function () { console.log(&quot;03 beforeMount&quot;, this.msg); // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 }, // 这是第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 mounted: function () { console.log(&quot;04 mounted&quot;, this.msg); // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了 // 此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 }, }); &lt;/script&gt;&lt;/html&gt; 打印结果： 运行期间的生命周期函数 beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染 DOM 节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。 PS：数据发生变化时，会触发这两个方法。不过，我们一般用 watch 来做。 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--这个div区域就是MVVM中的 View--&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;修改flag&quot; @click=&quot;myMethod&quot; /&gt; &lt;h3 id=&quot;h3&quot;&gt;{{ flag }}&lt;/h3&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data: { msg: &quot;hello vue&quot;, flag: false, }, methods: { myMethod: function () { this.flag = true; }, }, // 接下来的是运行中的两个事件 // 这时候，我们的界面还没有被更新【但是，数据被更新了吗？ 数据肯定被更新了】 beforeUpdate() { console.log(&quot;-------------05 beforeUpdate&quot;, this.msg); // 结论：当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 console.log( &quot;界面上DOM元素显示的内容：&quot; + document.getElementById(&quot;h3&quot;).innerText ); console.log(&quot;data 中的 msg 数据：&quot; + this.flag); }, updated() { console.log(&quot;-------------06 updated&quot;, this.msg); // 结论：updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 console.log( &quot;界面上DOM元素显示的内容：&quot; + document.getElementById(&quot;h3&quot;).innerText ); console.log(&quot;data 中的 msg 数据：&quot; + this.flag); }, }); &lt;/script&gt;&lt;/html&gt; 当我们点击按钮后，运行效果是： 可以看出： 当执行 beforeUpdate 的时候，页面中的显示的数据还是旧的，但此时 data 数据是最新的 updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 3、销毁期间的生命周期函数 beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 PS：可以在 beforeDestory 里清除定时器、或清除事件绑定。","link":"/2019/10/03/notes/2019/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"},{"title":"🥩十月实践总结","text":"1.some 方法123456789101112131415161718// some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。// some() 方法会依次执行数组的每个元素：//如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。//如果没有满足条件的元素，则返回false。//注意： some() 不会对空数组进行检测。//注意： some() 不会改变原始数组。const arr = [12,13,14,19,17]function checkNum = data = &gt;{return data&gt;=18}function check = ()=&gt;{console.log(arr.some(checkNum))}// true 2.for each 方法123456789101112131415// forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。// 注意: forEach() 对于空数组是不会执行回调函数的。// array.forEach(function(currentValue, index, arr), thisValue)// 注意:currentValue是当前的值// index是当前下标// arr是当前数组const arr = [1,2,3,5,7]arr.forEach((value,index,arr)=&gt;{console.log(value,index)})//1,0//2,1//3,2//4,7 3.for of 方法详细在 https://juejin.im/post/5e82978af265da47ee3f4a16 4.image 的 onload 方法,是等图片加载完在执行的方法5.回调函数,在进行输入验证时用到的回调 详细见代码 12345678910const arr =[12,14,23,14]//最简单的回调,打印循环的数字console.log('callback')const printNum= (data,callback)=&gt;{ for(let i of data){ callback(i) }}printNum(arr,data=&gt;console.log(data))//12 14 23 14 6.关于遍历1.for infor in 循环键值 12345const arr = [1,2,3]for(let i in arr ){console.log(arr[i])}//1 2 3 缺点是: 数组的键名是数字，但是 for…in 循环是以字符串作为键名“0”、“1”、“2”等等。如果你使用字符串的 index 去参与某些运算（”2” + 1 == “21”），运算结果可能会不符合预期。 for…in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for…in 循环会以任意顺序遍历键名。 总之，for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。 2.for of这个是循环对值 掘金一篇文章 说的很好,for of 与 forEach 相比,优点还是不少的, 可以就地结构 可以迭代(数组,字符串,set 和 map 对象等) 循环 JavaScript 普通对象等 不同于 forEach 方法，它可以与 break、continue 和 return 配合使用。 提供了遍历所有数据结构的统一操作接口。 缺点是不太适合太长的数组对象等的循环 3.forEach","link":"/2019/10/12/notes/2019/%E4%B8%80%E6%9C%88%E5%AE%9E%E8%B7%B5%F0%9F%9A%97/"},{"title":"🍕居中的方式","text":"flex 布局的方法这个是我常用的方法,一般现在布局我基本上用 flex 布局,然后辅助一些别的,常用的 flex 布局让元素居中的方法是 12345.parent { display: flex; /*Flex布局*/ display: -webkit-flex; /* Safari */ align-items: center; /*设置子元素在侧轴方向上的布局*/} 给父元素设置上之后,里面的子元素就可以了实现了,这种方法属于元素高度未知的情况下,点击这里也可以看看 flex 布局的基本方法. 绝对定位 + translate 位移translate:移动，是 transform 的一个方法,通过 translate()方法，元素从其当前位置移动，根据给定的 left(x 坐标)和 top(y 坐标)位置参数： 123456div { background-color: red; position: absolute; 绝对定位的盒子 top: 50%; 首先，让上边线居中 transform: translateY(-50%); 然后，利用translate，往上走自己宽度的一半【推荐写法】 } 绝对定位 + margin:auto12345.element { position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; /* 有了这个就自动居中了 */} 代码两个关键点： 上下左右均 0 位置定位； margin: auto 行内元素诸如文本啊等行内元素可以直接使用 1text-align: center; 来居中,让文字的行高 等于 盒子的高度，可以让单行文本垂直居中。 块级元素给元素设置：（让当前元素在父亲里居中） 1234/* //方式一 */margin: auto;/* 方式二 */margin: 0 auto; 上面的代码， margin: auto相当于margin: auto auto auto auto。margin: 0 auto相当于margin: 0 auto 0 auto，四个值分别对应上右下左。 垂直方向：根据规范，margin-top: auto 和 margin-bottom: auto，其计算值为 0。 水平方向：水平方向的 auto，其计算值取决于可用空间（剩余空间）。","link":"/2019/04/18/notes/2019/%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"title":"🌯搞懂JS中的 var let 与const的区别","text":"总结:let 与 var 的区别 var 在 javascript 中是支持预解析的，而 let 不支持预解析 var 可以重复定义同一个变量，但是 let 不可以 let 可以形成块级作用域，在 es6 之前 javascript 只有函数作用域，没有块级作用域 const 与 var 的不同，以上三点完全适用 const**const 与 let 或是 var 还有两点不同 用 const 定义常量必须赋值。不赋值的话，没有任何意思，所以报错 const 是用来定义常量的，常量定义之后是不允许改变的 下文转自思否作者:guanghua地址:https://segmentfault.com/a/1190000016491581let 是 ES6 新增的变量类型，用来代替 var 的一些缺陷，跟 var 相比主要有以下区别： 1. let 使用块级作用域在 ES6 之前，ES5 中 js 只有全局作用域和函数作用域，例如： 1234if (true) { var a = &quot;name&quot;;}console.log(&quot;a&quot;, a); // name 作用域是一个独立的地盘，让变量不外泄出去，但是上例中的变量就外泄了出去，所以此时 JS 没有块级作用域的概念。 1234567var a = 1;function fn() { var a = 2; console.log(&quot;fn&quot;, a);}console.log(&quot;global&quot;, a);fn(); 全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易冲突。ES6 中加入块级作用域之后： 1234if (true) { let a = &quot;name&quot;;}console.log(&quot;a&quot;, a); // Uncaught ReferenceError: a is not defined 块作用域内用 let 声明的变量，在块外是不可见的，如果引用的话就会报错。 2. let 约束了变量提升而不是没有变量提升在 js 中变量和函数都会提升: 12345function fn() { console.log(&quot;a&quot;, a); var a = 1; // undefind}fn(); a 其实已经在调用前被声明了，只是没有被初始化。JavaScript 会把作用域里的所有变量和函数提到函数的顶部声明,相当于： 123456function fn() { var a; console.log(&quot;a&quot;, a); a = 1; // undefind}fn(); JavaScript 会使用undefined缺省值创建变量 a,事实上浏览器并没有把声明语句放到作用域的顶部，在编译阶段，控制流进入域，该域所有的变量和函数的声明先进入内存，文中代码的相对位置不会变动。变量提升指的是变量声明的提升，不会提升变量的初始化和赋值。并且函数的提升优先级大于变量的提升: 12345678function fn() { console.log(&quot;a&quot;, a); var a = 1; function a() { console.log(&quot;I am a function&quot;); }}fn(); // ƒ a () {console.log('I am a function');} 在上例中， let 声明的变量的作用域之外引用该变量会报错，但是否可理解为 let 没有变量提升？ 12345let a = &quot;outside&quot;;if (true) { console.log(a); //Uncaught ReferenceError: a is not defined let a = &quot;inside&quot;;} 报出错误 a 没有被定义，而不是引用了全局作用域里的 a，说明 let 声明的 a 也被提升了。原因是 let 设计中的暂时性死区：当前作用域顶部到该变量声明位置中间的部分，都是该 let 变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let 声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。 3. let 禁止重复声明变量使用 var 可以重复声明变量，但是 let 不允许在同一块作用域内重复声明同一个变量： 1234567891011121314function fn() { var a = 1; let a = 2; console.log(a); //SyntaxError}function fn() { let a = 1; let a = 2; console.log(a); //SyntaxError}function fn(a) { let a = 2; console.log(a); //SyntaxError} 上述代码会报语法错误； 4. let 不会成为全局对象的属性我们在全局范围内声明一个变量时，这个变量自动成为全局对象的属性（在浏览器和Node.js环境下，这个全局对象分别是window和global)，但 let 是独立存在的变量，不会成为全局对象的属性： 1234var a = 1;console.log(window.a); //1let b = 2;console.log(window.b); // undefined 5. const 声明的常量以上 let 的规则同样适用于 const，但是跟 let 的区别是 const 声明的变量不能重新赋值，所以** const 声明的变量必须经过初始化**。 123const a = 1;a = 2; // // Uncaught TypeError: Assignment to constant variableconst b; // Uncaught SyntaxError: Missing initializer in const declaration","link":"/2019/10/03/notes/2019/%E6%90%9E%E6%87%82JS%E4%B8%AD%E7%9A%84%20var%20let%20%E4%B8%8Econst%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"🍔最近易忘知识点","text":"export deault12345678export 用于导出函数或者变量,将他们暴露在外面可以导出:export const str=&quot;helloworld&quot;,export const str2=&quot;iamdog&quot;,export const str3=&quot;hahaha&quot;格式也可以是export default{str,str2,str3}在应用时需要用打括号{}引入 (相对路径与绝对路径)相对路径:./代表他的所在目录,../代表父级目录../../代表 父级目录 的 父级目录/代表根目录绝对路径比如:http://www.baidu.com/image/img1.jpg callback 回调函数callback 回调函数本质上是一个函数调用另一个函数在 JavaScript 中，回调函数具体的定义为：函数 A 作为参数(函数引用)传递到另一个函数 B 中，并且这个函数 B 执行函数 A。我们就说函数 A 叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。因此 callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。简单的例子: 12345678function fun1(callback) { const num = 12; callback(num);}fun1((num) =&gt; { console.log(num);});//打印结果是 22 什么是 localStorage对浏览器来说，使用 Web Storage 存储键值对比存储 Cookie 方式更直观，而且容量更大，它包含两种：localStorage 和 sessionStorage sessionStorage（临时存储） ：为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载 localStorage（长期存储） ：与 sessionStorage 一样，但是浏览器关闭后，数据依然会一直存在 所以上次使用 cookie 的时候就遇到了一个坑,设置后马上访问 session 会获取不到,蛋疼,还需要刷新一下,原因是:当我们首次访问设置 Cookie 的页面时，服务器会把设置的 Cookie 值通过响应头发送过来，告诉浏览器将 cookie 存储的本地相应文件夹中（注意:第一次访问时本地还没有存储 Cookie,所以此时获取不到值）;当第二次访问(或在进行 cookie 设置后,过期前所有的访问)时，请求头信息你中都会把 Cookie 值携带。(百度到的,暂时还没理解透彻,先搬过来). 保存1234567891011//对象const info = { name: &quot;hou&quot;, age: 24, id: &quot;001&quot; };//字符串const str = &quot;haha&quot;;localStorage.setItem(&quot;hou&quot;, JSON.stringify(info));localStorage.setItem(&quot;zheng&quot;, str); 获取123var data1 = JSON.parse(localStorage.getItem(&quot;hou&quot;));var data2 = localStorage.getItem(&quot;zheng&quot;); 删除12345//删除某个localStorage.removeItem(&quot;hou&quot;);//删除所有localStorage.clear(); 监听12345Storage 发生变化（增加、更新、删除）时的 触发，同一个页面发生的改变不会触发，只会监听同一域名下其他页面改变 Storagewindow.addEventListener('storage', function (e) { console.log('key', e.key); console.log('oldValue', e.oldValue); console.log('newValue', e.newValue); console.log('url', e.url);}) vue 中的使用根据我的需求来的一个默认记住上次选择的,很简单添加数据的时候,下次添加默认记住我上次的选择所以,在添加或者提交的时候存储值即可,localStorage.setItem(‘projectId’,me.workhourData.projectId+”,”+me.workhourData.projectManager); 在打开新建页面的时候获取一下就好了,只需要判断非空就行 12345678910//记住上次选中的审核人if (localStorage.length &gt; 0) { var mydata = localStorage.getItem(&quot;projectId&quot;); if (mydata != null) { var arr3 = mydata.split(&quot;,&quot;); if (arr3[0] == me.workhourData.projectId) { me.workhourData.projectManager = arr3[1]; } }} 注意点localStorage 有效期是永久的。一般的浏览器能存储的是 5MB 左右。sessionStorage api 与 localStorage 相同。sessionStorage 默认的有效期是浏览器的会话时间（也就是说标签页关闭后就消失了）。localStorage 作用域是协议、主机名、端口。（理论上，不人为的删除，一直存在设备中）sessionStorage 作用域是窗口、协议、主机名、端口。知道了这些知识点后，你的问题就很好解决了。localStorage 是 window 上的。所以不需要写 this.localStorage，vue 中如果写 this，是指 vue 实例。会报错 HTML 加载过程 加载 HTML-DOM 结构2)CSS 和 JS3)图片和多媒体4)加载事件触发","link":"/2019/04/17/notes/2019/%E6%9C%80%E8%BF%91%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"🌭Vue项目中的权限判断","text":"写在前面 这个项目是基于 花裤衩 大佬的 vue-element-admin 框架来进行开发的,其中涉及的代码及是基于大佬的代码 今儿有个需求,就是给现有的项目增加一个登录权限判断,之后便在网上开始翻阅有关 vue 登录权限判断的方法,大部分都是用动态路由,在 meta 头里定义一个 roles,然后在 permission 里面进行路由验证 123456{ path: 'home', name: 'home', meta: { roles: ['admin']//或者是roles:['editor'] } 然后在用动态路由来进行判断权限 12345678const role = &quot;editor&quot;;router.beforeEach((to, from, next) =&gt; { if (to.meta.roles.includes(role)) { next(); } else { next({ path: &quot;/404&quot; }); }}); 又去翻了翻项目的权限,这个略复杂一点,需要根据不同的权限展示不同的页面,也要根据不同的权限来配置不同的功能,由于本项目是基于 花裤衩 大佬的 vue-element-admin 框架改的,看了下原先的登陆状态判断,便在这个基础上稍微改动了一下.本项目的不同的权限: 12345678910111213141516171819//这样的权限还有很多export const power1 = { key: &quot;power1&quot;, label: &quot;权限1&quot;, children: [ { label: &quot;权限1-1&quot;, key: &quot;power1_1&quot; }, { label: &quot;权限1-2&quot;, key: &quot;power1_2&quot; }, { label: &quot;权限1-3&quot;, key: &quot;power1_3&quot; }, ],};export const power2 = { key: &quot;power2&quot;, label: &quot;权限2&quot;, children: [ { label: &quot;权限2-1&quot;, key: &quot;power2_1&quot; }, { label: &quot;权限2-2&quot;, key: &quot;power2_2&quot; }, { label: &quot;权限2-3&quot;, key: &quot;power2_3&quot; }, ],}; 首先再配置完路由和不同账号的权限之后,在获取个人信息之后拿到 permission 字段里的关于本账号的权限,然后其返回的格式是我传给后端的,后端又原封不动传了回来,那就直接拿来用吧(选择权限时用的 Element UI 的树形控件,只能这样存了 😏) 1234567891011121314151617181920permission = [ { key: &quot;power1&quot;, label: &quot;权限1&quot;, children: [ { label: &quot;权限1-1&quot;, key: &quot;power1_1&quot; }, { label: &quot;权限1-2&quot;, key: &quot;power1_2&quot; }, { label: &quot;权限1-3&quot;, key: &quot;power1_3&quot; }, ], }, { key: &quot;power2&quot;, label: &quot;权限2&quot;, children: [ { label: &quot;权限2-1&quot;, key: &quot;power2_1&quot; }, { label: &quot;权限2-2&quot;, key: &quot;power2_2&quot; }, { label: &quot;权限2-3&quot;, key: &quot;power2_3&quot; }, ], },]; 之后在 VUEX 里面把存取的路由给进行一下判断,为了保证权限的唯一性,在每个权限对象里都加了一个 key 来标识, 12345678910111213import { asyncRoutes, constantRoutes } from '@/router'//拿到路由信息//在permission里调用下这个方法,把账号权限给传过来generateRoutes({ commit }, { roles }) { const permissions = JSON.parse(roles) return new Promise(resolve =&gt; { let accessedRoutes = asyncRoutes || [] //判断完是否有权限之后在重新赋值,hasPermission用来判断是否有权限,然后用Array.splice方法删除掉没权限的页面 accessedRoutes = hasPermission(accessedRoutes, permissions) //然后把访问到的路由存到vuex里面, commit('SET_ROUTES', accessedRoutes) resolve(accessedRoutes) }) } 然后在 permission.js 里面定义一下获取个人信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//获取tokenconst hasToken = getToken();if (hasToken) { if (to.path === &quot;/login&quot;) { next({ path: &quot;/&quot; }); NProgress.done(); } else { //登录之后保存个人信息到vuex,然后获取账号权限,这时个人信息应该也要保存 //因为之前登陆时已经获取了账号的权限保存到路由里了,这时是有权限的 const hasRoles = store.getters.user.role; if (hasRoles) { next(); } else { try { let user = {}; //调用个人信息的接口,这样每一次刷新之后用户信息都会重新获取,以防丢失 await auth .getUserInfo() .then((data) =&gt; { user = data; }) .catch((error) =&gt; { throw error.data.message; }); //定义一个roles来保存权限 const roles = user.permissions; //保存到vuex里面 await store.dispatch(&quot;auth/setUserInfo&quot;, user); //调用上面代码中的权限判断 const accessRoutes = await store.dispatch(&quot;permission/generateRoutes&quot;, { roles, }); //添加到路由里 router.addRoutes(accessRoutes); next({ ...to, replace: true }); } catch (error) { await store.dispatch(&quot;auth/clearAuth&quot;); Message({ message: error || &quot;Has Error&quot;, type: &quot;error&quot;, duration: 5 * 1000, }); next(`/login?redirect=${to.path}`); NProgress.done(); } } }} else { if (whiteList.indexOf(to.path) !== -1) { next(); } else { next(`/login?redirect=${to.path}`); NProgress.done(); }} 这样不同权限的页面就显示好了,剩下的就是显示不同的功能了这时就用上了花裤衩大佬的自定义指令了 12345678910111213141516171819import store from &quot;@/store&quot;;//这是已经存好的权限的数组,把之前拿到的permission中的power1和power2中的children中的key保存里面,定义唯一性import { newRoles } from &quot;@/set/index&quot;;export default { inserted(el, binding, vnode) { const { value } = binding; const permissionRoles = value; if (value &amp;&amp; value.length &gt; 0) { const hasPermission = newRoles.some((p) =&gt; { return permissionRoles === p; }); if (!hasPermission) { el.parentNode &amp;&amp; el.parentNode.removeChild(el); } } else { throw new Error(`need roles! Like v-permission=&quot;['power1_1']&quot;`); } },}; 使用 123&lt;el-button type=&quot;primary&quot; v-permission=&quot;['power1_1']&quot;&gt; 修改&lt;/el-button&gt;","link":"/2020/07/01/notes/2020/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E5%88%A4%E6%96%AD/"},{"title":"🍿关于WEB WORKER","text":"1.web worker 概述Web Worker 作用是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。 Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。 2.注意要点Web Worker 有以下几个使用注意点。 （1）同源限制 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 （2）DOM 限制 Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。 （3）通信联系 Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 （4）脚本限制 Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。 （5）文件限制 Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。 3.用法 主线程定义: 1let worker = new Worker(&quot;./time.js&quot;); 然后，主线程调用worker.postMessage()方法，向 Worker 发消息。 1worker.postMessage(60); worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。 接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。 1234worker.onmessage = (event) =&gt; { console.log(event); this.msg = event.data;}; 上面代码中，事件对象的data属性可以获取 Worker 发来的数据。 Worker 完成任务以后，主线程就可以把它关掉。 1worker.terminate(); web worker 线程Worker 线程内部需要有一个监听函数，监听message事件。 1234567self.addEventListener( &quot;message&quot;, function (e) { self.postMessage(&quot;You said: &quot; + e.data); }, false); 除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。 1234567891011self.onmessage = (event) =&gt; { let num = event.data; let t = setInterval(() =&gt; { self.postMessage(--num); console.log(num); if (num &lt; 0) { clearInterval(t); self.close(); } }, 1000);}; self.close()用于在 Worker 内部关闭自身。","link":"/2020/12/19/notes/2020/WEB%20WORKER_/"},{"title":"🍜base64图片下载","text":"下载图片 1234567891011121314151617181920212223242526272829303132function download(imgData) { // const imgData = 'base64---------' // 这里放需要下载的base64 downloadFile(&quot;二维码.png&quot;, imgData);}// 下载function downloadFile(fileName, content) { const aLink = document.createElement(&quot;a&quot;); const blob = base64ToBlob(content); // new Blob([content]); const evt = document.createEvent(&quot;HTMLEvents&quot;); evt.initEvent(&quot;click&quot;, true, true); // initEvent 不加后两个参数在FF下会报错 事件类型，是否冒泡，是否阻止浏览器的默认行为 aLink.download = fileName; aLink.href = URL.createObjectURL(blob); // aLink.dispatchEvent(evt); aLink.click();}// base64转blobfunction base64ToBlob(code) { const parts = code.split(&quot;;base64,&quot;); const contentType = parts[0].split(&quot;:&quot;)[1]; const raw = window.atob(parts[1]); const rawLength = raw.length; const uInt8Array = new Uint8Array(rawLength); for (let i = 0; i &lt; rawLength; ++i) { uInt8Array[i] = raw.charCodeAt(i); } return new Blob([uInt8Array], { type: contentType });}export { download, base64ToBlob, downloadFile }; 最后导出","link":"/2020/06/12/notes/2020/base64%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/"},{"title":"Git的基本使用","text":"新建在当前目录新建一个 Git 代码库git init 新建一个目录，将其初始化为 Git 代码库git init [project-name] 下载一个项目和它的整个代码历史git clone [url] 配置显示当前的 Git 配置git config --list 编辑 Git 配置文件git config -e [--global] 设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 增加/删除添加指定文件到暂存区git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录git add [dir] 添加当前目录的所有文件到暂存区git add . 添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交git add -p 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file] 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 提交提交暂存区到仓库区git commit -m [message] 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message] 提交工作区自上次 commit 之后的变化，直接到仓库区git commit -a 提交时显示所有 diff 信息git commit -v 使用一次新的 commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次 commit 的提交信息git commit --amend -m [message] 重做上一次 commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 添加指定文件到暂存区分支列出所有本地分支git branch 列出所有远程分支git branch -r 列出所有本地分支和远程分支git branch -a 新建一个分支，但依然停留在当前分支git branch [branch-name] 新建一个分支，并切换到该分支git checkout -b [branch] 新建一个分支，指向指定 commitgit branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区git checkout [branch-name] 切换到上一个分支git checkout - 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支git merge [branch] 选择一个 commit，合并进当前分支git cherry-pick [commit] 删除分支git branch -d [branch-name] 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签列出所有 taggit tag 新建一个 tag 在当前 commitgit tag [tag] 新建一个 tag 在指定 commitgit tag [tag] [commit] 删除本地 taggit tag -d [tag] 删除远程 taggit push origin :refs/tags/[tagName] 查看 tag 信息git show [tag] 提交指定 taggit push [remote] [tag] 提交所有 taggit push [remote] --tags 新建一个分支，指向某个 taggit checkout -b [branch] [tag] 查看信息显示有变更的文件git status 显示当前分支的版本历史git log 显示 commit 历史，以及每次 commit 发生变更的文件git log --stat 搜索提交历史，根据关键词`git log -S [keyword] 显示某个 commit 之后的所有变动，每个 commit 占据一行git log [tag] HEAD --pretty=format:%s 显示某个 commit 之后的所有变动，其”提交说明”必须符合搜索条件git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file] 显示指定文件相关的每一次 diffgit log -p [file] 显示过去 5 次提交git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序git shortlog -sn 显示指定文件是什么人在什么时间修改过git blame [file] 显示暂存区和工作区的差异git diff 显示暂存区和上一个 commit 的差异git diff --cached [file] 显示工作区与当前分支最新 commit 之间的差异git diff HEAD 显示两次提交之间的差异git diff [first-branch]...[second-branch] 显示今天你写了多少行代码git diff --shortstat &quot;@{0 day ago}&quot; 显示某次提交的元数据和内容变化git show [commit] 显示某次提交发生变化的文件git show --name-only [commit] 显示某次提交时，某个文件的内容git show [commit]:[filename] 显示当前分支的最近几次提交git reflog 远程同步下载远程仓库的所有变动git fetch [remote] 显示所有远程仓库git remote -v 显示某个远程仓库的信息git remote show [remote] 增加一个新的远程仓库，并命名git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch] 上传本地指定分支到远程仓库git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force 推送所有分支到远程仓库git push [remote] --all 撤销恢复暂存区的指定文件到工作区git checkout [file] 恢复某个 commit 的指定文件到暂存区和工作区git checkout [commit] [file] 恢复暂存区的所有文件到工作区git checkout . 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变git reset [file] 重置暂存区与工作区，与上一次 commit 保持一致git reset --hard 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变git reset [commit] 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致git reset --hard [commit] 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变git reset --keep [commit] 新建一个 commit，用来撤销指定 commit后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit] 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 生成一个可供发布的压缩包git archive","link":"/2020/03/11/notes/2020/git/"},{"title":"🍟关于Promise与async的二三事","text":"最近关于 Promise 看了好一些文章来阐述用途,再加上异步编程和 async 与 await 的用法弄的属实头大,但是看了好几遍之后感觉有点上道了,然后抓紧吧我知道的理解的记录下来了,我在这里只是阐述我对 Promise 和 async 的一些理解,关于 promise 和 async 的更多细节可以去查看阮一峰老师的ES6 入门,或者边城大大的理解 JavaScript 的 async/await第一次写文章,可能会有语句不通顺或者有些理解错误的地方,也请多多指正,多多批评 😄 1.关于同步与异步js 是单线程的,执行时只能等待前一个任务执行完毕才会执行下一个,但当前一个任务耗时过长时,就会发生阻塞,如果所有任务都是同步执行的话,就可能会造成浏览器卡顿等情况,所以那些执行时间很长的任务都应该异步来处理.关于异步模式编程的实现方式可以具体去参考阮一峰老师的Javascript 异步编程的 4 种方法 2.Promise第一次接触 Promise 时是去年学 Vue 的时用到的 Axios 库,里面的方法封装好了直接用的时候就是下面这种方法,后来在补习基础以及 ES6 是才知道这原来是用 Promise 封装的,但是碍于脑子笨没怎么理解,就还是只是会用,到前段时间在看的时候有那么一点点理解了. 123456789101112const data = { ...};services .getinfo(data) .then((res) =&gt; { console.log(res); }) .catch((err) =&gt; { console.log(err); }); Promise 是异步编程的一个解决方案,它有三个状态,pending（正在进行）、fulfilled（执行成功）和rejected（执行失败),而且只有两种状态:A:正在进行==&gt;执行成功B:正在进行==&gt;执行失败且状态一旦发生变化,就不会再继续变了,成功就是成了,失败就是失败了,不会再去发生变化,这种结果会一直持续到任务结束.而且在执行过程中是无法取消的.用法上 Promise 是一个构造函数,可以用new关键字来创建一个 Promise 对象,它接受两个函数参数,分别是resolve和reject, 1234567891011121314151617181920const myPromise = new Promise((resolve, reject) =&gt; { //接受两个参数 resolve, reject let num = 0; setTimeout(() =&gt; { // 执行一个异步操作 num = Math.random() * 10; // 生成一个随机数 if (num &gt; 5) { resolve(num); // 如果符合条件,就将Promise的状态从正在执行变为执行成功 } else reject(num); // 如果不符合条件就会将状态由正在执行变为执行失败 }, 2000);});myPromise .then((p) =&gt; { // then用于为Promise实例添加状态改变时的回调 console.log(p); }) .catch((e) =&gt; { // catch用于指定发生错误时的回调 console.log(e); }); 换句话说就是执行成功就在执行 then 方法,执行失败就去执行 catch 方法 1234567891011121314151617const myPromise = new Promise((resolve, reject) =&gt; { const num = Math.random() * 10; if (num &gt; 5) { resolve(num); } else reject(num);});myPromise .then((p) =&gt; { console.log(p); }) .catch((e) =&gt; { console.log(e); });console.log(1); // 注意!!//执行结果是//1//7.696298823399228 这里的 myPromise 创建完后立即执行,但是因为是异步的, then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行,所以才会最后输出随机数在网页的图片加载时,我们往往用的都是异步的,在执行 JS 时会去发送请求,等到主线程执行完了,图片也请求完了那么图片就会显示了.我对Promise的理解的可能不是特别的深,所以请见谅. Promise的缺点1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 3.async 与 awaitasync 其实就是异步(asynchronous) async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 12345async function fun() { const result = &quot;helloworld&quot;; return result;}fun(); 运行结果:可以发现,async函数返回的是一个 Promise 对象,而且 async 函数中的 return 的返回值可以做为 Promise 中 then 方法的回调的参数,如果抛出了异常,也可用 catch 方法来处理,且只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数.既然 async 返回了一个 Promise 对象,那么 await 的作用是什么呢?正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果.如果不是 Promise 对象，就直接返回对应的值. 12345678async function fun() { return await &quot;tom&quot;;}fun.then((p) =&gt; { console.log(p);});// tom await 后面的值并不一定是一个 Promise 对象,也就是说,如果 await 后面的不是一个 Promise 对象,那么这个值就是要”等待”的处理结果加了 await 之后,await 后面的语句都会变成同步的,按照顺序来执行语句, 1234567891011121314151617function myPromise(num) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(num); }, 2000); });}async function fun() { let a = await myPromise(1); let b = await myPromise(2); let c = await myPromise(3); console.log(a, b, c); console.log(&quot;is end&quot;);}fun();//1,2,3//is end 但是还有一点要注意是在 await 后面的异步语句如果抛出异常,就会时整个函数中断执行 123456789101112131415161718//把上面的代码进行修改const myPromis = () =&gt; { return new Promise((resolve, reject) =&gt; { let num = 0; setTimeout(() =&gt; { num = Math.random() * 10; if (num &gt; 5) { resolve(num); } else reject(num); }, 2000); });};async function fun() { let a = await myPromis(); console.log(a); console.log(&quot;is end &quot;);}fun(); 执行结果:结果是 3.75 小于 5,执行 reject,抛出异常,但是可以用 try…catch…来改写fun() 123456789101112async function fun() { let a = 0; try { a = await myPromis(); // 大于5执行try语句 } catch (e) { // 小于五抛出异常执行catch语句 console.log(e); a = 100; } console.log(a); console.log(&quot;is end &quot;);} 总的来说 async 与 await 就是可以简化 Promise,使其更直观的但要注意 async 与 await 的使用: await 关键字必须位于 async 函数内部 不能在普通箭头函数中使用 await 关键字，需要在箭头函数前面添加 async","link":"/2020/12/02/notes/2020/%E5%85%B3%E4%BA%8EPromise%E4%B8%8Easync%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/"},{"title":"axios的简单封装使用","text":"1.什么是 axios Promise based HTTP client for the browser and node.js axios 是一个用 Promise 封装的 HTTP 的请求库,现在大部分前端项目都是用的 axios,所以就拿出 axios 来举例 2.axios 的请求拦截直接上代码,以下代码的作用 先引入 axios 以及 Vuex 库 添加响应拦截,此时在这吧请求返回的信息做一下处理,或者是在这里对错误做一些处理 然后是封装 POST,GET,DELETE,PUT 请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// import store from '@/store'import axios from &quot;axios&quot;;import store from &quot;@/store&quot;;import vm from &quot;../main&quot;;// import { defaults } from 'js-cookie'const options = { // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 // transformResponse: [ // data =&gt; { // return data // } // ]};// 添加响应拦截器axios.interceptors.response.use( (response) =&gt; { // 对响应数据做点什么 return response; }, (error) =&gt; { // 对响应错误做点什么 // console.log(error.response) const res = error.response; if (res.status === 401) { // console.log('401401401401401401401401401401401401401401') store.dispatch(&quot;user/clearAuth&quot;); vm.$router.push(&quot;/login&quot;); } else if (res.status === 403) { // console.log('403403403403403403403403403403403403') } return Promise.reject(error); });const httpUrls = {};httpUrls.get = (url, data) =&gt; { let config = { method: &quot;GET&quot;, url: url, params: data, }; config = Object.assign(config, options); return axios(config) .then((res) =&gt; { return res; }) .catch((err) =&gt; { console.log(err); });};httpUrls.post = (url, data) =&gt; { let config = { method: &quot;POST&quot;, url: url, data: data, }; config = Object.assign(config, options); return axios(config) .then((res) =&gt; { return res; }) .catch((err) =&gt; { console.log(err); });};httpUrls.delete = (url, data) =&gt; { let config = { method: &quot;DELETE&quot;, url: url, params: data, }; config = Object.assign(config, options); return axios(config) .then((res) =&gt; { return res; }) .catch((err) =&gt; { console.log(err); });};httpUrls.put = (url, data) =&gt; { let config = { method: &quot;PUT&quot;, url: url, params: data, }; config = Object.assign(config, options); return axios(config) .then((res) =&gt; { return res; }) .catch((err) =&gt; { console.log(err); });};export { httpUrls }; 3.举例使用假如这是 test.js 中的内容 12345678import { httpUrls as http } from &quot;./http&quot;; // 引入http(引入请求)const request = {}; // 定义方法// 登陆request.login = (data) =&gt; { return http.post(&quot;/api/login&quot;, data); // 请求方法,传入参数};export default request; 定义一个 index.js 统一导出 12export { default as test } from &quot;./test&quot;;export { default as auth } from &quot;./auth&quot;; 在页面中使用 12345678import {test} form '@/src/api'test.login(data).then(res=&gt;{ console.log(res)}).catch(err=&gt;{ console.log(err)}).finally(result=&gt;{ console.log(result)})","link":"/2021/01/09/notes/2021/API%E7%9A%84%E5%B0%81%E8%A3%85/"},{"title":"前端基本知识-HTML","text":"文章目录: 常见的 HTML 标签有哪些 script 标签 同步、异步 HTML5的新特性有哪些 1.常见的 HTML 标签有哪些块级标签 div 常用块级容器，也是 css layout 的主要标签 p 段落、放一段文字 h1~h6 标题 h1 网页中最重要的内容：logo 网站的标题；网页中普通的标题 一般用 h3 或者 h4、h5 ul li 每一项前面都有一个点（无序列表） ol li 每一项前面都有对应的数字（有序列表） dl 定义列表 dt 列表项目 dd 项目描述 table 表格 caption 表格的标题 thead 表格的头部 tbody 表格的主体 tr 行 td 列 （普通的列，可以放在 tbody 下面） th 列 （只放在 thead 的里面，文字默认加粗） hr 分割线 form 表单 行内标签 span 通常放几个文字，或者小图标 a 超链接 自带下划线 b 加粗 strong 加粗强调 i 斜体 em 斜体强调 s 中划线（不推荐使用） strike 中划线 del 文档中已被删除的文本 br 强制换行 u 下划线 textarea 多行文本输入框 input 输入框 select 下拉列表 label input 元素定义标注（标记） img 图片 sub 下标 sup 上标 big 大字体文本 small 小字体文本 2.script 标签 同步、异步在 HTML 文件中, script 标签一般是放在 body 后面来加载的,因为放在 head 标签中会先等 js 全部加载完在开始加载网页主体内容, script 标签不带 defer 和 async 属性的话,脚本获取和执行都是同步,页面会被阻塞,浏览器都会按照 script 元素在页面中出现的先后顺序对他们依次进行解析 async 属性html5 的新属性,只适合用于外部脚本文件,异步模式,一旦下载完脚本,渲染引擎就会中断渲染,执行这个脚本以后,再继续渲染 defer 属性异步模式,会被延迟到整个页面都解析( DOM 结构完全生成，以及其他脚本执行完成)完毕后再运行,脚本加载不阻塞页面的解析,同时带有 defer 的脚本彼此之间,能保证其执行顺序,多个带有 defer 的脚本会按照它们在页面出现的顺序加载 defer 与 async 不同defer 属性是渲染完就执行,二 async 是下载完就执行","link":"/2021/01/21/notes/2021/HTML%E5%B8%B8%E7%94%A8/"},{"title":"react-router用法","text":"react-router 的官方文档 react-router 的 GitHub react-router 的 npm 包地址 比较靠谱一点的中文翻译 安装 安装命令: 1npm install react-router-dom 先简单介绍一下 react-router-dom 与 react-router 的区别:react-router-dom 是基于 react-router 加入了在浏览器运行环境下的一些功能,例如 Link 组件,BrowserRouter 和 HashRouter 组件,在安装 react-router-dom 会自动一起安装 react-router 的.那么就开始正式的学习吧. 使用基本路由1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from 'react';import ReactDOM from 'react-dom'; import './index.css'; // 引入react-routerimport {BrowserRouter as Router, Route, Switch, Link} from &quot;react-router-dom&quot;; // Router: 所有路由器组件的通用底层接口,我们可以把它看做是react路由的一个路由外层盒子，它里面的内容就是我们单页面应用的路由以及路由组件// Route: 代表了你的路由界面，path代表路径，component代表路径所对应的界面// Switch: 渲染与位置匹配的第一个子元素&lt;Route&gt;或&lt;Redirect&gt;,其中的&lt;Route&gt;在路径相同的情况下，只匹配第一个，这个可以避免重复匹配；// Link: 会被渲染成一个&lt;a&gt;&lt;/a&gt;,是react路由中的点击切换到哪一个组件的链接// 定义inbox组件const Inbox = function () {return &lt;div&gt;Inbox&lt;/div&gt;}// 定义about组件const About = function () {return &lt;div&gt;about&lt;/div&gt;}// 定义App组件class App extends React.Component { render() { return ( &lt;Router&gt; &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;ul&gt; {/* Link标签开始导航 */} &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt; about&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/inbox&quot;&gt;inbox&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; {this.props.children} &lt;/div&gt; {/* 在这Switch标签匹配路由*/} &lt;Switch&gt; &lt;Route path=&quot;/about&quot;&gt;&lt;About/&gt;&lt;/Route&gt; &lt;Route path=&quot;/inbox&quot;&gt;&lt;Inbox/&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/Router&gt; ) }}// 基本使用ReactDOM.render( &lt;React.StrictMode&gt; &lt;App&gt;&lt;/App&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); ======= 未完待续 =====","link":"/2021/01/11/notes/2021/react-router%E7%94%A8%E6%B3%95/"},{"title":"🥘初级前端基础知识","text":"先立个 Flag,接下来每一个点写一篇文章来巩固吧哈哈哈哈哈 HTML 常见的 HTML 标签有哪些 哪些标签需要配合使用 常见标签都有哪些属性，这些属性的作用 meta 标签，a 标签，table tr td script 标签 同步、异步 标签的大概怎么进行分类，分类之间有什么区别 CSS 常见的 CSS 布局以及实现方式 选择器 伪类伪元素 浮动 定位 flex 布局 *grid 布局 常见的 CSS 属性 ： 背景设置，字体设置（行高，对齐等等） CSS 过渡 CSS 动画 盒模型 *CSS 新特性 例如变量声明等 CSS 预处理器的使用 ECMAScript 基础的语法 常见对象的 API： String ， Array ， Date 常见的新特性： 箭头函数，let const ，Promise, Map Set ,Class ,模块导入导出 闭包 *原型链 this 指向问题 , call apply bind 的使用 *同步异步执行 async await 浏览器方面 常用的 DOM 操作 常用的 BOM API : storage 的操作，ajax 与 fetch，CSS 过渡与动画开始或完成时触发的相应的事件，浏览器信息的获取，history 的操作，hash 的监听，全屏，自定义事件， 事件响应机制（冒泡捕获） *拖动 API *浏览器加载页面的过程 浏览器常用的事件 *canvas *svg 框架VUE 组件的生命周期 组件之间的数据通信（好多方式，掌握常用的即可） 组件怎么封装，应该考虑什么 VUE 常用的 API : watch 以及怎么取消一个 watch VUE 提供的几个组件 translation keep-alive 怎么使用，有没有给组件添加新的生命周期钩子 VUE 配套相关 router 怎么使用，跳转、传参 router 常见的守卫钩子。进入路由前要做点什么，离开之后也要做点什么。 VUEX 的几个概念，怎么使用 VUEX 注意分模块处理，mutation action 名字全局声明统一 小程序相关目前小程序太多了，也没有统一的规范，但大部分都跟微信小程序很像，所以一微信小程序为范本即可 小程序的生命周期、页面的生命周期 小程序进入页面的几种方式，不同方式进入页面是怎么获取参数 小程序常用的 API、 组件 小程序自定义组件 小程序调试工具的使用、调试方法 一些工具的使用Git Git 的工作流程（主要是分支管理） 常用的命令 （提交操作，分支操作等等） Chrome 调试面板的使用：network element application 等等 浏览器插件的安装使用（vue-devtools 等） 调试技巧 打断点 二分找问题 配合 console.log 暂未想到 优化加载方面暂无 代码层面 js 节流、防抖、分时 图片懒加载 图片加载失败的处理 loading 的添加 js 的一些 dom 操作使用 CSS 实现 CSS 使用硬件加速","link":"/2021/01/05/notes/2021/%E5%88%9D%E7%BA%A7%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"前端基本知识-CSS","text":"文章目录: 常见的 CSS 布局以及实现方式 [ ]选择器 伪类伪元素 [ ]CSS3 的一些新特性 [ ]*CSS 新特性 例如变量声明等 先挖坑😂","link":"/2021/01/30/notes/2021/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86-css/"},{"title":"🥓路上的知识点(坑)","text":"1.vuerouter Uncaught (in promise)这个是在用 vue-router 进行跳转时,重复点击了元素两次,控制台会报错,据翻看大佬的解释，vue-router ≥3.0 版本回调形式以及改成 promise api 的形式了，返回的是一个 promise，如果没有捕获到错误，控制台始终会出现如图的警告，针对于路由跳转相同的地址，目前的解决方案: 123this.$router.push(&quot;/location&quot;).catch((err) =&gt; { console.log(err);}); 大佬说是在 main.js 文件下加入如下代码： 12345import Router from &quot;vue-router&quot;;const originalPush = Router.prototype.push;Router.prototype.push = function push(location) { return originalPush.call(this, location).catch((err) =&gt; err);}; 结果：加入后亲测有效，确实不再提示这个错误了 2.css 设置多行溢出1234/* 单行溢出 */overflow: hidden;text-overflow:ellipsis;white-space: nowrap; 12345多行溢出display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 3.刷新的方法:123//用的是reload方法window.location.reload()//这种方法不好的方式是会刷新空白,用户体验很不好 4.css 鼠标 🈲 用123pointer-events: none;cursor: default;opacity: 1; /* 设置透明度 */ 5,get 方法与 post 方法区别 http超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 http 方法：HEAD: 与 GET 相同，但只返回 HTTP 报头，不返回文档主体 PUT: 上传指定的 URI 表示 DELETE: 删除指定资源 OPTIONS: 返回服务器支持的 HTTP 方法 CONNECT: 把请求连接转换到透明的 TCP/IP 通道 POST: 向指定的资源提交要被处理的数据 12345// 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2复制代码 GET: 从指定的资源请求数据 GET 和 POST 的区别 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制(2048 字符),IE 和 Safari 浏览器限制 2k;Opera 限制 4k;Firefox，Chrome 限制 8k GET 请求只应当用于取回数据 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 6.js 求平面两点之间的距离12345678// 数据可以以数组方式存储，也可以是对象方式let a = { x: &quot;6&quot;, y: 10 }, b = { x: 8, y: 20 };function distant(a, b) { let dx = Number(a.x) - Number(b.x); let dy = Number(a.y) - Number(b.y); return Math.pow(dx * dx + dy * dy, 0.5);} 7.css 禁止用户选择 👆12345678body { -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;} 8.for in 与 for of 方法1234567891011121314151617let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2) function find(arr) { for (let num of arr) { console.log(num) } } find(arr)//for of中的num是完整的arr数组中的值let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2) function find(arr) { for (let num in arr) { console.log(num) } } find(arr)//但是for in 中的num相当于下标,只有输出arr[num]才能获得数组中的值 9.数组去重12345678910111213//indexOf()方法let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2) function find(arr) { let res = [] for (let num of arr) { if (res.indexOf(num) === -1) { res.push(num) } } return res } console.log(find(arr))\\ //1,2,3,5,6 10.如何提高首频加载速度 1.js 外联文件放到 body 底部，css 外联文件放到 head 内2.http 静态资源尽量用多个子域名 3.服务器端提供 html 和 http 静态资源时最好开启 gzip 4.在 js,css,img 等资源响应的 http headers 里设置 expires,last-modified 5.尽量减少 http requests 的数量6.js/css/html/img 资源压缩 7.使用 css spirtes，可以减少 img 请求次数 8.大图使用 lazyload 懒加载 9.避免 404，减少外联 js 10.减少 cookie 大小可以提高获得响应的时间 11.减少 dom elements 的数量 12.使用异步脚本，动态创建脚本 11.简述一下你对 HTML 语义化的理解用正确的标签做正确的事情。 html 语义化让页面的内容结构化，便于对浏览器、搜索引擎解析; 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 12.请描述一下 cookies，sessionStorage 和 localStorage 的区别cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。存储大小： cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭 13.css overflow 属性overflow 属性规定当内容溢出元素框时发生的事情。 这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。 值: visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 让 overflow:scroll 平滑滚动1-webkit-overflow-scrolling: touch; 14.position 中的 relative 和 absolute 的定位原点问题absolute 生成绝对定位的元素，相对于值不为 static 的第一个父元素进行定位。 fixed （老 IE 不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值 15.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧 ？ png24 位的图片在 iE6 浏览器上出现背景，解决方案是做成 PNG8. 浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6 双边距 bug:块属性标签 float 后，又有横行的 margin 情况下，在 ie6 显示 margin 比设置的大。浮动 ie 产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}这种情况之下 IE 会产生 20px 的距离，解决方案是在 float 的标签样式控制中加入 ——*display:inline;将其转化为行内属性。(*这个符号只有 ie6 会识别)渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“\\9”这一标记，将 IE 游览器从所有情况中分离出来。 接着，再次使用“+”将 IE8 和 IE7、IE6 分离开来，这样 IE8 已经独立识别。css .bb{ background-color:red;/所有识别/ background-color:#00deff\\9; /IE6、7、8 识别/ +background-color:#a200ff;/IE6、7 识别/ background-color:#1e0bd1;/_IE6 识别/ } IE 下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用 getAttribute()获取自定义属性; Firefox 下,只能使用 getAttribute()获取自定义属性。 解决方法:统一通过 getAttribute()获取自定义属性。 IE 下,even 对象有 x,y 属性,但是没有 pageX,pageY 属性; Firefox 下,event 对象有 pageX,pageY 属性,但是没有 x,y 属性。 解决方法：（条件注释）缺点是在 IE 浏览器下可能会增加额外的 HTTP 请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后 hover 样式就不出现了 被点击访问过的超链接样式不在具有 hover 和 active 了解决方法是改变 CSS 属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 16.css 优化,提高性能关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp 对 css 进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 17.让页面里的字体变清晰，变细用 CSS 怎么做1-webkit-font-smoothing: antialiased; 18.This 对象的理解 this 总是指向函数的直接调用者（而非间接调用者）； 如果有 new 关键字，this 指向 new 出来的那个对象； 在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 Window； 19.什么是 window 对象? 什么是 document 对象 window 对象是指浏览器打开的窗口。 document 对象是 Documentd 对象（HTML 文档对象）的一个只读引用，window 对象的一个属性。 20.什么是闭包（closure），为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部 21.如何判断一个对象谁否属于某个类123456789101112131415161718192021if (a instanceof Person) { alert(&quot;yes&quot;);}//instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。// 判断对象类型最好的方式// 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。//而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。Object.prototype.toString.call(&quot;&quot;); // [object String]Object.prototype.toString.call(1); // [object Number]Object.prototype.toString.call(true); // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined); // [object Undefined]Object.prototype.toString.call(null); // [object Null]Object.prototype.toString.call(new Function()); // [object Function]Object.prototype.toString.call(new Date()); // [object Date]Object.prototype.toString.call([]); // [object Array]Object.prototype.toString.call(new RegExp()); // [object RegExp]Object.prototype.toString.call(new Error()); // [object Error]Object.prototype.toString.call(document); // [object HTMLDocument]Object.prototype.toString.call(window); //[object global] window 是全局对象 global 的引用 22.new 一个对象的过程1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2、属性和方法被加入到 this 引用的对象中。3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 23.在 Vue 中的遍历方法 v-for 控制循环次数的方法1.截取循环的数据 v-for=”(item,index) in domainList.slice(0, 2)” 用这样的方法可以截取循环的数据长度，从而控制循环的次数2.通过 v-if 来控制 v-for=”(item,index) in domainList” v-if=”index&lt;3” 在标签下紧跟 v-if 来进行控制，这里是用索引来进行控制的，所以循环的时候记得把 index 这个参数加到 v-for 循环中。 24.箭头函数对于箭头函数，this 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。 25.获取接口数据的定义的数组12345678list: { course: { public_assesses: [], course_contents: [], public_collects: [], introduction: '' } }, 在获取数据时，由于接口返回的数据嵌套过多，导致页面渲染报错，在定义数组保存接口数据时，可以定义好要接受的数据的“模版”，或者说把要使用的数据拿出来单独赋值 26.vue-router 跳转页面时传参成功但是页面没有刷新12345watch: { '$route' (to, from) { this.$router.go(0) } }, 用 watch 监听 router 属性是否有变化，然后决定是否重新刷新页面 27.设置默认显示的子路由12345678910111213141516171819202122232425262728293031323334353637path: '/', component: () =&gt; import('@/views/home_page/index'), name: 'home_page', redirect: 'index_cntent',//用redirect指出默认显示的子路由 children: [{ path: '/about_menu', component: () =&gt; import('@/views/menu/about_menu'), name: 'about_menu' }, { path: '/dervice_menu', component: () =&gt; import('@/views/menu/dervice_menu'), name: 'dervice_menu' }, { path: '/product_menu', component: () =&gt; import('@/views/menu/product_menu'), name: 'product_menu' }, { path: '/service_menu', component: () =&gt; import('@/views/menu/service_menu'), name: 'service_menu' }, { path: '/index_cntent', component: () =&gt; import('@/views/menu/content'), name: 'index_cntent' } ]}, 28 关于 vue warn 的警告解决一般出现 vue warn 的时候一般是 vue 数据渲染出错，绑定的某个值可能赋值出错，像是给了 undefined，或者是原本是图片地址却给了个字符串之类错误，往往导致这方面的错误的时候，提示里一般没有相关文件具体到哪一行那个语法出错，但是会提示了是那个文件，去文件里面逐一排查就好 29.最简单的方式实现前端下载功能（window.location）用window.locatio.href=“xxxx?”+（其他字段）+'&amp;(其他字段)'的方式可以实现打开新的窗口下载文件，前提是后端给返回文件的下载地址，默认打开地址的话像是图片会直接预览 30.textarea 禁止拖动,固定宽高1resize: none; 31.控制 v-for 循环的次数1234561、通过html的标签里面v-if对超出范围的进行隐藏&lt;div v-for=&quot;(item,index) in courselist&quot; v-if=&quot;index &lt; 6&quot; :key='index'&gt;&lt;/div&gt;2、通过sclie截取数组的长度控制循环的次数&lt;div v-for=&quot;(item,index) in courselist.slice(0,6)&quot; :key=&quot;index&quot;&gt;&lt;/div&gt; 32.Cannot read property ‘$createElement’ of undefined12Cannot read property '$createElement' of undefined一般是vue router报出错误,一般是 在写 component 时 写成了 components 33.@click.native12@click.native 是vue在绑定点击事件时用到的指令,因为要给组件加上点击事件,所以要加上.native 子组件内部处理click事件然后向外发送click事件：$emit(&quot;click&quot;.fn) 34.如何用 css 绘制一个点或者圆形12345678910i { width: 6px; height: 6px; border-radius: 100%; display: inline-block; margin-top: -2px; vertical-align: middle; background: red; margin-right: 8px;} 35.判断一个字符串是不是日期 1234const date = &quot;2020-01-01&quot;;if (isNaN(date) &amp;&amp; !isNaN(Date.parse(date))) { console.log(&quot;yes&quot;);}","link":"/2020/12/19/notes/2020/%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9(%E5%9D%91)%F0%9F%90%B1_%F0%9F%91%A4/"}],"tags":[{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"2019","slug":"notes/2019","link":"/categories/notes/2019/"},{"name":"2020","slug":"notes/2020","link":"/categories/notes/2020/"},{"name":"2021","slug":"notes/2021","link":"/categories/notes/2021/"}]}