{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"12345678{ &quot;Name&quot;:&quot;LiuLin&quot;, &quot;Age&quot;:23, &quot;Job&quot;:&quot;Front-end develospert&quot;, &quot;Will use&quot;:&quot;Html,Css,JavaScript,Golang&quot;, &quot;Web framework&quot;: &quot;Vue,React&quot;, &quot;School&quot;:&quot;Yantai university&quot;}","link":"/about/details.html"},{"title":"","text":"切换显示 Aloha 👋, I'm LiuLin A passionate frontend developer,currently working hard to learn back-end knowledge. 🔭 I’m currently working on Gin 🌱 I’m currently learning React,Golang 💬 Ask me about Vue or JavaScript ⚡ Fun fact I think i am funny Languages and Tools:","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"19总结","text":"写了一些废话又删除了,像是流水账一般,才反应过来差不多该简练一点哈哈哈 19年开始做前端19年回顾了Html,Css,Js,又进一步学习了Vue和Uniapp,这一年写过web端,也写过小程序哈啊哈哈哈等快到年底了才开始继续学ES6,Sass的一些知识哈哈哈争取2020年把&lt;JavaScript 高程&gt;看完吧 接下来的计划 攒钱,去一趟重庆,走一趟大西北环形路线(大西北是真的神奇,太吸引人了) 技术提升,20 年争取把基础打好,ES6,配置 Webpack,试着看下 Vue 的原理,在着也可 以了解下 React,可以自己造几个轮子用用 生活,学会做菜 早睡早起,锻炼身体 减肥,开始跑步 看书,继续之前的书单 找一个爱好 让我们加油吧,一切都会变好的(其实到了2020年底我又重新看了眼我的计划,除了出去玩全部都完成了哈哈哈哈)","link":"/2019/12/29/notes/2019/2020%E5%B9%B4%E8%AE%A1%E5%88%92/"},{"title":"🍤JavaScript错误处理","text":"JavaScript错误处理语句 try 语句测试代码块的错误。 catch 语句处理错误。 throw 语句创建自定义错误。 finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188//try语句通常搭配catch语句来使用try {...}catch{...}//比如try{console.logg(123)//程序会在这里停止执行}catch{console.log(321)//在上一句抛出异常后会执行 catch 中的语句,此时输出 321} //321//或者后面常常也会配合 finally 一起使用try {...}catch{...} finally{...}//比如try{console.logg(123)//程序会在这里停止执行}catch{console.log(321)//在上一句抛出异常后会执行 catch 中的语句,此时输出 321}finally{console.log(456)} //321 //456throw 语句throw 语句允许我们创建自定义错误。正确的技术术语是：创建或抛出异常（exception）。//比如throw hello有时,try...catch...语句也会和throw语句一起使用let a= 12try{ if(a===&quot;&quot;) throw &quot;值为空&quot; if(isNaN(a)) throw &quot;不是数字&quot;; a = Number(a);if(a&gt;10) throw &quot;这个数字比10大&quot; if (a&lt;10) throw &quot;这个数字比10小&quot;} catch(err){console.log(err)} //没有catch语句时,程序会中断,先执行finally语句,然后再抛出异常信息 function cleansUp() { try { throw new Error('出错了……'); console.log('此行不会执行'); } finally { console.log('完成清理工作'); }}cleansUp()// 完成清理工作// Uncaught Error: 出错了……// at cleansUp (&lt;anonymous&gt;:3:11)// at &lt;anonymous&gt;:10:1 function idle(x) { try { console.log(x); return 'result'; } finally { console.log('FINALLY'); }}idle('hello')// hello// FINALLY上面代码中，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。而且，这个函数的返回值还是result。下面的例子说明，return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。var count = 0;function countUp() { try { return count; } finally { count++; }}countUp()// 0count// 1上面代码说明，return语句里面的count的值，是在finally代码块运行之前就获取了。下面是finally代码块用法的典型场景。openFile();try { writeFile(Data);} catch(e) { handleError(e);} finally { closeFile();}上面代码首先打开一个文件，然后在try代码块中写入文件，如果没有发生错误，则运行finally代码块关闭文件；一旦发生错误，则先使用catch代码块处理错误，再使用finally代码块关闭文件。下面的例子充分反映了try...catch...finally这三者之间的执行顺序。function f() { try { console.log(0); throw 'bug'; } catch(e) { console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 } finally { console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 } console.log(5); // 不会运行}var result = f();// 0// 1// 3result// false上面代码中，catch代码块结束执行之前，会先执行finally代码块。catch代码块之中，触发转入finally代码块的标志，不仅有return语句，还有throw语句。function f() { try { throw '出错了！'; } catch(e) { console.log('捕捉到内部错误'); throw e; // 这句原本会等到finally结束再执行 } finally { return false; // 直接返回 }}try { f();} catch(e) { // 此处不会执行 console.log('caught outer &quot;bogus&quot;');}// 捕捉到内部错误上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。try代码块内部，还可以再使用try代码块。try { try { consle.log('Hello world!'); // 报错 } finally { console.log('Finally'); } console.log('Will I run?');} catch(error) { console.error(error.message);}// Finally// consle is not defined上面代码中，try里面还有一个try。内层的try报错（console拼错了），这时会执行内层的finally代码块，然后抛出错误，被外层的catch捕获。 JavaScript原生错误类型 1.SyntaxError 对象SyntaxError对象是解析代码时发生的语法错误。 1234567// 变量名错误var 1a;// Uncaught SyntaxError: Invalid or unexpected token// 缺少括号console.log 'hello');// Uncaught SyntaxError: Unexpected string 上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出SyntaxError。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。 2.ReferenceError 对象ReferenceError对象是引用一个不存在的变量时发生的错误。 123// 使用一个不存在的变量unknownVariable// Uncaught ReferenceError: unknownVariable is not defined 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。 123// 等号左侧不是变量console.log() = 1// Uncaught ReferenceError: Invalid left-hand side in assignment 上面代码对函数console.log的运行结果赋值，结果引发了ReferenceError错误。 3.RangeError 对象RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。 1234567// 数组长度不得为负数new Array(-1)// Uncaught RangeError: Invalid array length 函数堆栈超过最大值 4.TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 123456new 123// Uncaught TypeError: number is not a funcvar obj = {};obj.unknownMethod()// Uncaught TypeError: obj.unknownMethod is not a function 上面代码的第二种情况，调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。 5.URIError 对象URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 12decodeURI('%2')// URIError: URI malformed 6.EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。","link":"/2019/07/11/notes/2019/JavaScript%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%F0%9F%99%85/"},{"title":"🍢vue生命周期函数","text":"介绍 vue实例的生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期。 生命周期钩子：就是生命周期事件的别名而已。 生命周期钩子 = 生命周期函数 = 生命周期事件。 生命周期函数的主要分类根据上面这张图，我们把生命周期函数主要分为三类。 1、创建期间的生命周期函数 beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板。我们可以在这里进行Ajax请求。 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示。（mounted之后，表示真实DOM渲染完了，可以操作DOM了） 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这个div区域就是MVVM中的 View--&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'hello vuejs' }, // 这是第1个生命周期函数，表示实例完全被创建出来之前，会执行它 beforeCreate: function () { console.log('01 beforeCreate', this.msg); //注意：在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 },// 这是第2个生命周期函数 created: function () { console.log('02 created', this.msg); //注意：如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 },// 这是第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中 beforeMount: function () { console.log('03 beforeMount', this.msg); // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 },// 这是第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 mounted: function () { console.log('04 mounted', this.msg); // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了 // 此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 } });&lt;/script&gt;&lt;/html&gt; 打印结果： 运行期间的生命周期函数 beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。 PS：数据发生变化时，会触发这两个方法。不过，我们一般用watch来做。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;vue2.5.16.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这个div区域就是MVVM中的 View--&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;修改flag&quot; @click=&quot;myMethod&quot;&gt; &lt;h3 id=&quot;h3&quot;&gt;{{ flag }}&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue({ el: '#app', data: { msg: 'hello vue', flag: false },methods: { myMethod: function () { this.flag = true; } },// 接下来的是运行中的两个事件 // 这时候，我们的界面还没有被更新【但是，数据被更新了吗？ 数据肯定被更新了】 beforeUpdate() { console.log('-------------05 beforeUpdate', this.msg);// 结论：当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 console.log('界面上DOM元素显示的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据：' + this.flag) }, updated() { console.log('-------------06 updated', this.msg);// 结论：updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 console.log('界面上DOM元素显示的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据：' + this.flag) } });&lt;/script&gt;&lt;/html&gt; 当我们点击按钮后，运行效果是： 可以看出： 当执行 beforeUpdate 的时候，页面中的显示的数据还是旧的，但此时 data 数据是最新的 updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 3、销毁期间的生命周期函数 beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 PS：可以在beforeDestory里清除定时器、或清除事件绑定。","link":"/2019/10/03/notes/2019/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"},{"title":"🥩十月实践总结","text":"1.some方法123456789101112131415161718// some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。// some() 方法会依次执行数组的每个元素：//如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。//如果没有满足条件的元素，则返回false。//注意： some() 不会对空数组进行检测。//注意： some() 不会改变原始数组。const arr = [12,13,14,19,17]function checkNum = data = &gt;{return data&gt;=18}function check = ()=&gt;{console.log(arr.some(checkNum))}// true 2.for each方法123456789101112131415// forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。// 注意: forEach() 对于空数组是不会执行回调函数的。// array.forEach(function(currentValue, index, arr), thisValue)// 注意:currentValue是当前的值// index是当前下标// arr是当前数组const arr = [1,2,3,5,7]arr.forEach((value,index,arr)=&gt;{console.log(value,index)})//1,0//2,1//3,2//4,7 3.for of 方法详细在 https://juejin.im/post/5e82978af265da47ee3f4a16 4.image的onload方法,是等图片加载完在执行的方法5.回调函数,在进行输入验证时用到的回调 详细见代码 12345678910const arr =[12,14,23,14]//最简单的回调,打印循环的数字console.log('callback')const printNum= (data,callback)=&gt;{ for(let i of data){ callback(i) }}printNum(arr,data=&gt;console.log(data))//12 14 23 14 6.关于遍历1.for infor in循环键值 12345const arr = [1,2,3]for(let i in arr ){console.log(arr[i])}//1 2 3 缺点是: 数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。如果你使用字符串的 index 去参与某些运算（”2” + 1 == “21”），运算结果可能会不符合预期。 for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for…in循环会以任意顺序遍历键名。 总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 2.for of这个是循环对值 掘金一篇文章 说的很好,for of 与forEach相比,优点还是不少的, 可以就地结构 可以迭代(数组,字符串,set和map对象等) 循环JavaScript普通对象等 不同于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。 缺点是不太适合太长的数组对象等的循环 3.forEach","link":"/2019/10/12/notes/2019/%E4%B8%80%E6%9C%88%E5%AE%9E%E8%B7%B5%F0%9F%9A%97/"},{"title":"🍕居中的方式","text":"flex布局的方法这个是我常用的方法,一般现在布局我基本上用flex布局,然后辅助一些别的,常用的flex布局让元素居中的方法是 123456.parent{ display: flex;/*Flex布局*/ display: -webkit-flex; /* Safari */ align-items: center;/*设置子元素在侧轴方向上的布局*/} 给父元素设置上之后,里面的子元素就可以了实现了,这种方法属于元素高度未知的情况下,点击这里也可以看看flex布局的基本方法. 绝对定位 + translate 位移translate:移动，是transform的一个方法,通过translate()方法，元素从其当前位置移动，根据给定的left(x坐标)和top(y坐标)位置参数： 123456div { background-color: red; position: absolute; 绝对定位的盒子 top: 50%; 首先，让上边线居中 transform: translateY(-50%); 然后，利用translate，往上走自己宽度的一半【推荐写法】 } 绝对定位 + margin:auto12345.element { position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; /* 有了这个就自动居中了 */} 代码两个关键点： 上下左右均0位置定位； margin: auto 行内元素诸如文本啊等行内元素可以直接使用 1text-align: center; 来居中,让文字的行高 等于 盒子的高度，可以让单行文本垂直居中。 块级元素给元素设置：（让当前元素在父亲里居中） 1234//方式一 margin: auto; 方式二 margin: 0 auto; 上面的代码， margin: auto相当于margin: auto auto auto auto。margin: 0 auto相当于margin: 0 auto 0 auto，四个值分别对应上右下左。 垂直方向：根据规范，margin-top: auto 和 margin-bottom: auto，其计算值为0。 水平方向：水平方向的 auto，其计算值取决于可用空间（剩余空间）。","link":"/2019/04/18/notes/2019/%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"title":"🌯搞懂JS中的 var let 与const的区别","text":"总结:let与var的区别 var在javascript中是支持预解析的，而let不支持预解析 var可以重复定义同一个变量，但是let不可以 let可以形成块级作用域，在es6之前javascript只有函数作用域，没有块级作用域 const与var的不同，以上三点完全适用const**const与let或是var还有两点不同 用const定义常量必须赋值。不赋值的话，没有任何意思，所以报错 const是用来定义常量的，常量定义之后是不允许改变的 下文转自思否作者:guanghua地址:https://segmentfault.com/a/1190000016491581let 是 ES6新增的变量类型，用来代替 var 的一些缺陷，跟 var 相比主要有以下区别： 1. let 使用块级作用域在 ES6之前，ES5中js只有全局作用域和函数作用域，例如： 1234if(true) { var a = 'name'}console.log('a',a) // name 作用域是一个独立的地盘，让变量不外泄出去，但是上例中的变量就外泄了出去，所以此时 JS 没有块级作用域的概念。 1234567var a = 1;function fn() { var a = 2; console.log('fn',a);}console.log('global',a);fn(); 全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易冲突。ES6中加入块级作用域之后： 1234if(true) { let a = 'name'}console.log('a',a) // Uncaught ReferenceError: a is not defined 块作用域内用 let 声明的变量，在块外是不可见的，如果引用的话就会报错。 2. let 约束了变量提升而不是没有变量提升在 js 中变量和函数都会提升: 12345function fn() { console.log('a',a); var a = 1; // undefind}fn() a其实已经在调用前被声明了，只是没有被初始化。JavaScript会把作用域里的所有变量和函数提到函数的顶部声明,相当于： 123456function fn() { var a; console.log('a',a); a = 1; // undefind}fn() JavaScript会使用undefined缺省值创建变量a,事实上浏览器并没有把声明语句放到作用域的顶部，在编译阶段，控制流进入域，该域所有的变量和函数的声明先进入内存，文中代码的相对位置不会变动。变量提升指的是变量声明的提升，不会提升变量的初始化和赋值。并且函数的提升优先级大于变量的提升: 12345678function fn() { console.log('a', a); var a = 1; function a () { console.log('I am a function'); } } fn() // ƒ a () {console.log('I am a function');} 在上例中， let 声明的变量的作用域之外引用该变量会报错，但是否可理解为 let 没有变量提升？ 12345let a = 'outside';if(true) { console.log(a);//Uncaught ReferenceError: a is not defined let a = &quot;inside&quot;;} 报出错误 a 没有被定义，而不是引用了全局作用域里的 a，说明 let 声明的 a 也被提升了。原因是 let 设计中的暂时性死区：当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。 3. let 禁止重复声明变量使用 var 可以重复声明变量，但是 let 不允许在同一块作用域内重复声明同一个变量： 1234567891011121314function fn (){ var a = 1; let a = 2; console.log(a); //SyntaxError}function fn (){ let a = 1; let a = 2; console.log(a); //SyntaxError}function fn (a){ let a = 2; console.log(a); //SyntaxError} 上述代码会报语法错误； 4. let不会成为全局对象的属性我们在全局范围内声明一个变量时，这个变量自动成为全局对象的属性（在浏览器和Node.js环境下，这个全局对象分别是window和global)，但let是独立存在的变量，不会成为全局对象的属性： 1234var a = 1;console.log(window.a); //1let b = 2;console.log(window.b); // undefined 5. const 声明的常量以上 let 的规则同样适用于 const，但是跟 let 的区别是 const 声明的变量不能重新赋值，所以** const 声明的变量必须经过初始化**。 123const a = 1;a = 2; // // Uncaught TypeError: Assignment to constant variableconst b; // Uncaught SyntaxError: Missing initializer in const declaration","link":"/2019/10/03/notes/2019/%E6%90%9E%E6%87%82JS%E4%B8%AD%E7%9A%84%20var%20let%20%E4%B8%8Econst%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"🍔最近易忘知识点","text":"export deault12345678export 用于导出函数或者变量,将他们暴露在外面可以导出:export const str=&quot;helloworld&quot;,export const str2=&quot;iamdog&quot;,export const str3=&quot;hahaha&quot;格式也可以是export default{str,str2,str3}在应用时需要用打括号{}引入 (相对路径与绝对路径)相对路径:./代表他的所在目录,../代表父级目录../../代表 父级目录 的 父级目录/代表根目录绝对路径比如:http://www.baidu.com/image/img1.jpg callback回调函数callback回调函数本质上是一个函数调用另一个函数在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。因此callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。简单的例子: 12345678function fun1(callback){const num =12; callback(num)}fun1((num)=&gt;{console.log(num)})//打印结果是 22 什么是localStorage对浏览器来说，使用 Web Storage 存储键值对比存储 Cookie 方式更直观，而且容量更大，它包含两种：localStorage 和 sessionStorage sessionStorage（临时存储） ：为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载 localStorage（长期存储） ：与 sessionStorage 一样，但是浏览器关闭后，数据依然会一直存在 所以上次使用cookie的时候就遇到了一个坑,设置后马上访问session会获取不到,蛋疼,还需要刷新一下,原因是:当我们首次访问设置Cookie的页面时，服务器会把设置的Cookie值通过响应头发送过来，告诉浏览器将cookie存储的本地相应文件夹中（注意:第一次访问时本地还没有存储Cookie,所以此时获取不到值）;当第二次访问(或在进行cookie设置后,过期前所有的访问)时，请求头信息你中都会把Cookie值携带。(百度到的,暂时还没理解透彻,先搬过来). 保存12345678910111213//对象 const info = { name: 'hou', age: 24, id: '001' }; //字符串 const str=&quot;haha&quot;; localStorage.setItem('hou', JSON.stringify(info)); localStorage.setItem('zheng', str); 获取1234var data1 = JSON.parse(localStorage.getItem('hou')); var data2 = localStorage.getItem('zheng'); 删除12345//删除某个 localStorage.removeItem('hou');//删除所有localStorage.clear(); 监听12345Storage 发生变化（增加、更新、删除）时的 触发，同一个页面发生的改变不会触发，只会监听同一域名下其他页面改变 Storagewindow.addEventListener('storage', function (e) { console.log('key', e.key); console.log('oldValue', e.oldValue); console.log('newValue', e.newValue); console.log('url', e.url);}) vue中的使用根据我的需求来的一个默认记住上次选择的,很简单添加数据的时候,下次添加默认记住我上次的选择所以,在添加或者提交的时候存储值即可,localStorage.setItem(‘projectId’,me.workhourData.projectId+”,”+me.workhourData.projectManager); 在打开新建页面的时候获取一下就好了,只需要判断非空就行 12345678910//记住上次选中的审核人 if(localStorage.length&gt;0){ var mydata = localStorage.getItem('projectId'); if(mydata!=null){ var arr3=mydata.split(&quot;,&quot;); if(arr3[0]==me.workhourData.projectId){ me.workhourData.projectManager=arr3[1]; } } } 注意点localStorage有效期是永久的。一般的浏览器能存储的是5MB左右。sessionStorage api与localStorage相同。sessionStorage默认的有效期是浏览器的会话时间（也就是说标签页关闭后就消失了）。localStorage作用域是协议、主机名、端口。（理论上，不人为的删除，一直存在设备中）sessionStorage作用域是窗口、协议、主机名、端口。知道了这些知识点后，你的问题就很好解决了。localStorage是window上的。所以不需要写this.localStorage，vue中如果写this，是指vue实例。会报错 HTML加载过程 加载HTML-DOM结构2)CSS和JS3)图片和多媒体4)加载事件触发","link":"/2019/04/17/notes/2019/%E6%9C%80%E8%BF%91%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"🌭Vue项目中的权限判断","text":"写在前面 这个项目是基于 花裤衩 大佬的 vue-element-admin 框架来进行开发的,其中涉及的代码及是基于大佬的代码 今儿有个需求,就是给现有的项目增加一个登录权限判断,之后便在网上开始翻阅有关vue登录权限判断的方法,大部分都是用动态路由,在meta头里定义一个roles,然后在permission里面进行路由验证 123456{ path: 'home', name: 'home', meta: { roles: ['admin']//或者是roles:['editor'] } 然后在用动态路由来进行判断权限 12345678const role = 'editor'router.beforeEach((to, from, next) =&gt; { if (to.meta.roles.includes(role)) { next() } else { next({path: '/404'}) }}) 又去翻了翻项目的权限,这个略复杂一点,需要根据不同的权限展示不同的页面,也要根据不同的权限来配置不同的功能,由于本项目是基于 花裤衩 大佬的vue-element-admin框架改的,看了下原先的登陆状态判断,便在这个基础上稍微改动了一下.本项目的不同的权限: 1234567891011121314151617//这样的权限还有很多export const power1 = { key: 'power1', label: '权限1', children: [ { label: '权限1-1', key: 'power1_1' }, { label: '权限1-2', key: 'power1_2' }, { label: '权限1-3', key: 'power1_3' }, ]}export const power2 = { key: 'power2', label: '权限2', children: [ { label: '权限2-1', key: 'power2_1' }, { label: '权限2-2', key: 'power2_2' }, { label: '权限2-3', key: 'power2_3' }, ]} 首先再配置完路由和不同账号的权限之后,在获取个人信息之后拿到permission字段里的关于本账号的权限,然后其返回的格式是我传给后端的,后端又原封不动传了回来,那就直接拿来用吧(选择权限时用的Element UI 的树形控件,只能这样存了😏) 123456789101112131415161718permission = [{ key: 'power1', label: '权限1', children: [ { label: '权限1-1', key: 'power1_1' }, { label: '权限1-2', key: 'power1_2' }, { label: '权限1-3', key: 'power1_3' }, ]}, { key: 'power2', label: '权限2', children: [ { label: '权限2-1', key: 'power2_1' }, { label: '权限2-2', key: 'power2_2' }, { label: '权限2-3', key: 'power2_3' }, ]}] 之后在VUEX里面把存取的路由给进行一下判断,为了保证权限的唯一性,在每个权限对象里都加了一个key来标识, 12345678910111213import { asyncRoutes, constantRoutes } from '@/router'//拿到路由信息//在permission里调用下这个方法,把账号权限给传过来generateRoutes({ commit }, { roles }) { const permissions = JSON.parse(roles) return new Promise(resolve =&gt; { let accessedRoutes = asyncRoutes || [] //判断完是否有权限之后在重新赋值,hasPermission用来判断是否有权限,然后用Array.splice方法删除掉没权限的页面 accessedRoutes = hasPermission(accessedRoutes, permissions) //然后把访问到的路由存到vuex里面, commit('SET_ROUTES', accessedRoutes) resolve(accessedRoutes) }) } 然后在permission.js里面定义一下获取个人信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//获取tokenconst hasToken = getToken() if (hasToken) { if (to.path === '/login') { next({ path: '/' }) NProgress.done() } else { //登录之后保存个人信息到vuex,然后获取账号权限,这时个人信息应该也要保存 //因为之前登陆时已经获取了账号的权限保存到路由里了,这时是有权限的 const hasRoles = store.getters.user.role if (hasRoles) { next() } else { try { let user = {} //调用个人信息的接口,这样每一次刷新之后用户信息都会重新获取,以防丢失 await auth.getUserInfo() .then(data =&gt; { user = data }) .catch(error =&gt; { throw error.data.message }) //定义一个roles来保存权限 const roles = user.permissions //保存到vuex里面 await store.dispatch('auth/setUserInfo', user) //调用上面代码中的权限判断 const accessRoutes = await store.dispatch('permission/generateRoutes', { roles }) //添加到路由里 router.addRoutes(accessRoutes) next({ ...to, replace: true }) } catch (error) { await store.dispatch('auth/clearAuth') Message({ message: error || 'Has Error', type: 'error', duration: 5 * 1000 }) next(`/login?redirect=${to.path}`) NProgress.done() } } } } else { if (whiteList.indexOf(to.path) !== -1) { next() } else { next(`/login?redirect=${to.path}`) NProgress.done() } } 这样不同权限的页面就显示好了,剩下的就是显示不同的功能了这时就用上了花裤衩大佬的自定义指令了 1234567891011121314151617181920import store from '@/store'//这是已经存好的权限的数组,把之前拿到的permission中的power1和power2中的children中的key保存里面,定义唯一性import {newRoles} from '@/set/index'export default { inserted(el, binding, vnode) { const { value } = binding const permissionRoles = value if (value &amp;&amp; value.length &gt; 0) { const hasPermission = newRoles.some(p =&gt; { return permissionRoles === p }) if (!hasPermission) { el.parentNode &amp;&amp; el.parentNode.removeChild(el) } } else { throw new Error(`need roles! Like v-permission=&quot;['power1_1']&quot;`) } }} 使用 12&lt;el-button type=&quot;primary&quot; v-permission=&quot;['power1_1']&quot;&gt;修改&lt;/el-button&gt;","link":"/2020/07/01/notes/2020/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E5%88%A4%E6%96%AD/"},{"title":"🍿关于WEB WORKER","text":"1.web worker概述Web Worker 作用是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。 Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。 2.注意要点Web Worker 有以下几个使用注意点。 （1）同源限制 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 （2）DOM 限制 Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。 （3）通信联系 Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 （4）脚本限制 Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。 （5）文件限制 Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。 3.用法 主线程定义: 1let worker= new Worker('./time.js') 然后，主线程调用worker.postMessage()方法，向 Worker 发消息。 1worker.postMessage(60) worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。 接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。 1234worker.onmessage = (event) =&gt; { console.log(event) this.msg = event.data } 上面代码中，事件对象的data属性可以获取 Worker 发来的数据。 Worker 完成任务以后，主线程就可以把它关掉。 1worker.terminate(); web worker线程Worker 线程内部需要有一个监听函数，监听message事件。 123self.addEventListener('message', function (e) {self.postMessage('You said: ' + e.data);}, false); 除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。 12345678910111213self.onmessage = (event)=&gt; { let num = event.data let t = setInterval(() =&gt; { self.postMessage(--num) console.log(num) if (num&lt;0) { clearInterval(t) self.close() } }, 1000); } self.close()用于在 Worker 内部关闭自身。","link":"/2020/12/19/notes/2020/WEB%20WORKER_/"},{"title":"🍜base64图片下载","text":"下载图片 12345678910111213141516171819202122232425262728293031323334function download (imgData) { // const imgData = 'base64---------' // 这里放需要下载的base64 downloadFile('二维码.png', imgData)}// 下载function downloadFile (fileName, content) { const aLink = document.createElement('a') const blob = base64ToBlob(content) // new Blob([content]); const evt = document.createEvent('HTMLEvents') evt.initEvent('click', true, true) // initEvent 不加后两个参数在FF下会报错 事件类型，是否冒泡，是否阻止浏览器的默认行为 aLink.download = fileName aLink.href = URL.createObjectURL(blob) // aLink.dispatchEvent(evt); aLink.click()}// base64转blobfunction base64ToBlob (code) { const parts = code.split(';base64,') const contentType = parts[0].split(':')[1] const raw = window.atob(parts[1]) const rawLength = raw.length const uInt8Array = new Uint8Array(rawLength) for (let i = 0; i &lt; rawLength; ++i) { uInt8Array[i] = raw.charCodeAt(i) } return new Blob([uInt8Array], { type: contentType })}export { download, base64ToBlob, downloadFile } 最后导出","link":"/2020/06/12/notes/2020/base64%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/"},{"title":"🍟关于Promise与async的二三事","text":"最近关于Promise看了好一些文章来阐述用途,再加上异步编程和async与await的用法弄的属实头大,但是看了好几遍之后感觉有点上道了,然后抓紧吧我知道的理解的记录下来了,我在这里只是阐述我对Promise和async的一些理解,关于promise和async的更多细节可以去查看阮一峰老师的ES6入门,或者边城大大的理解 JavaScript 的 async/await第一次写文章,可能会有语句不通顺或者有些理解错误的地方,也请多多指正,多多批评😄 1.关于同步与异步js是单线程的,执行时只能等待前一个任务执行完毕才会执行下一个,但当前一个任务耗时过长时,就会发生阻塞,如果所有任务都是同步执行的话,就可能会造成浏览器卡顿等情况,所以那些执行时间很长的任务都应该异步来处理.关于异步模式编程的实现方式可以具体去参考阮一峰老师的Javascript异步编程的4种方法 2.Promise第一次接触Promise时是去年学Vue的时用到的Axios库,里面的方法封装好了直接用的时候就是下面这种方法,后来在补习基础以及ES6是才知道这原来是用Promise封装的,但是碍于脑子笨没怎么理解,就还是只是会用,到前段时间在看的时候有那么一点点理解了. 123456789101112const data = { ...};services .getinfo(data) .then((res) =&gt; { console.log(res); }) .catch((err) =&gt; { console.log(err); }); Promise 是异步编程的一个解决方案,它有三个状态,pending（正在进行）、fulfilled（执行成功）和rejected（执行失败),而且只有两种状态:A:正在进行==&gt;执行成功B:正在进行==&gt;执行失败且状态一旦发生变化,就不会再继续变了,成功就是成了,失败就是失败了,不会再去发生变化,这种结果会一直持续到任务结束.而且在执行过程中是无法取消的.用法上Promise是一个构造函数,可以用new关键字来创建一个Promise对象,它接受两个函数参数,分别是resolve和reject, 123456789101112131415161718const myPromise = new Promise((resolve, reject) =&gt; { //接受两个参数 resolve, reject let num = 0 setTimeout(() =&gt; { // 执行一个异步操作 num = Math.random() * 10;// 生成一个随机数 if (num &gt; 5) { resolve(num); // 如果符合条件,就将Promise的状态从正在执行变为执行成功 } else reject(num); // 如果不符合条件就会将状态由正在执行变为执行失败 }, 2000);});myPromise .then((p) =&gt; { // then用于为Promise实例添加状态改变时的回调 console.log(p); }) .catch((e) =&gt; { // catch用于指定发生错误时的回调 console.log(e); }); 换句话说就是执行成功就在执行then方法,执行失败就去执行catch方法 1234567891011121314151617const myPromise = new Promise((resolve, reject) =&gt; { const num = Math.random() * 10; if (num &gt; 5) { resolve(num); } else reject(num);});myPromise .then((p) =&gt; { console.log(p); }) .catch((e) =&gt; { console.log(e); });console.log(1); // 注意!!//执行结果是//1//7.696298823399228 这里的myPromise创建完后立即执行,但是因为是异步的, then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行,所以才会最后输出随机数在网页的图片加载时,我们往往用的都是异步的,在执行JS时会去发送请求,等到主线程执行完了,图片也请求完了那么图片就会显示了.我对Promise的理解的可能不是特别的深,所以请见谅. 3.async与awaitasync其实就是异步(asynchronous) async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456async function fun() { const result = &quot;helloworld&quot; return result}fun() 运行结果:可以发现,async函数返回的是一个Promise对象,而且async函数中的return的返回值可以做为Promise中then方法的回调的参数,如果抛出了异常,也可用catch方法来处理,且只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数.既然async返回了一个Promise对象,那么await的作用是什么呢?正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果.如果不是 Promise 对象，就直接返回对应的值. 12345678async function fun() { return await 'tom';}fun.then((p) =&gt; { console.log(p);});// tom await后面的值并不一定是一个Promise对象,也就是说,如果await后面的不是一个Promise对象,那么这个值就是要”等待”的处理结果加了await之后,await后面的语句都会变成同步的,按照顺序来执行语句, 1234567891011121314151617function myPromise (num) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(num) }, 2000); });};async function fun() { let a = await myPromise(1); let b = await myPromise(2); let c = await myPromise(3); console.log(a, b, c); console.log('is end');}fun();//1,2,3//is end 但是还有一点要注意是在await后面的异步语句如果抛出异常,就会时整个函数中断执行 12345678910111213141516171819//把上面的代码进行修改const myPromis = () =&gt; { return new Promise((resolve, reject) =&gt; { let num = 0; setTimeout(() =&gt; { num = Math.random() * 10; if (num &gt; 5) { resolve(num); } else reject(num); }, 2000); });};async function fun() { let a = await myPromis(); console.log(a); console.log(&quot;is end &quot;)}fun(); 执行结果:结果是3.75小于5,执行reject,抛出异常,但是可以用try…catch…来改写fun() 1234567891011async function fun() { let a = 0 try { a = await myPromis(); // 大于5执行try语句 } catch(e){ // 小于五抛出异常执行catch语句 console.log(e) a = 100 } console.log(a); console.log(&quot;is end &quot;)} 总的来说ssync与await就是可以简化Promise,使其更直观的但要注意async与await的使用: await关键字必须位于async函数内部 不能在普通箭头函数中使用await关键字，需要在箭头函数前面添加async","link":"/2020/12/02/notes/2020/%E5%85%B3%E4%BA%8EPromise%E4%B8%8Easync%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/"},{"title":"🥘初级前端基础知识","text":"先立个Flag,接下来每一个点写一篇文章来巩固吧哈哈哈哈哈 HTML 常见的HTML标签有哪些 哪些标签需要配合使用 常见标签都有哪些属性，这些属性的作用 meta 标签，a 标签，table tr td script 标签 同步、异步 标签的大概怎么进行分类，分类之间有什么区别 CSS 常见的 CSS 布局以及实现方式 选择器 伪类伪元素 浮动 定位 flex 布局 *grid 布局 常见的 CSS 属性 ： 背景设置，字体设置（行高，对齐等等） CSS 过渡 CSS 动画 盒模型 *CSS 新特性 例如变量声明等 CSS 预处理器的使用 ECMAScript 基础的语法 常见对象的API： String ， Array ， Date 常见的新特性： 箭头函数，let const ，Promise, Map Set ,Class ,模块导入导出 闭包 *原型链 this 指向问题 , call apply bind 的使用 *同步异步执行 async await 浏览器方面 常用的 DOM 操作 常用的 BOM API : storage 的操作，ajax 与 fetch，CSS 过渡与动画开始或完成时触发的相应的事件，浏览器信息的获取，history 的操作，hash 的监听，全屏，自定义事件， 事件响应机制（冒泡捕获） *拖动 API *浏览器加载页面的过程 浏览器常用的事件 *canvas *svg 框架 VUE 组件的生命周期 组件之间的数据通信（好多方式，掌握常用的即可） 组件怎么封装，应该考虑什么 VUE 常用的 API : watch 以及怎么取消一个 watch VUE 提供的几个组件 translation keep-alive 怎么使用，有没有给组件添加新的生命周期钩子 VUE 配套相关 router 怎么使用，跳转、传参 router 常见的守卫钩子。进入路由前要做点什么，离开之后也要做点什么。 VUEX 的几个概念，怎么使用 VUEX 注意分模块处理，mutation action 名字全局声明统一 小程序相关目前小程序太多了，也没有统一的规范，但大部分都跟微信小程序很像，所以一微信小程序为范本即可 小程序的生命周期、页面的生命周期 小程序进入页面的几种方式，不同方式进入页面是怎么获取参数 小程序常用的 API、 组件 小程序自定义组件 小程序调试工具的使用、调试方法 一些工具的使用 Git Git 的工作流程（主要是分支管理） 常用的命令 （提交操作，分支操作等等） Chrome 调试面板的使用：network element application 等等 浏览器插件的安装使用（vue-devtools等） 调试技巧 打断点 二分找问题 配合 console.log 暂未想到 优化 加载方面暂无 代码层面 js 节流、防抖、分时 图片懒加载 图片加载失败的处理 loading 的添加 js 的一些 dom 操作使用 CSS 实现 CSS 使用硬件加速","link":"/2021/01/05/notes/2021/%E5%88%9D%E7%BA%A7%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"🥓路上的知识点(坑)","text":"1.vuerouter Uncaught (in promise)这个是在用vue-router进行跳转时,重复点击了元素两次,控制台会报错,据翻看大佬的解释，vue-router ≥3.0版本回调形式以及改成promise api的形式了，返回的是一个promise，如果没有捕获到错误，控制台始终会出现如图的警告，针对于路由跳转相同的地址，目前的解决方案: 1this.$router.push('/location').catch(err =&gt; { console.log(err) }) 大佬说是在main.js文件下加入如下代码： 12345import Router from 'vue-router'const originalPush = Router.prototype.pushRouter.prototype.push = function push(location) { return originalPush.call(this, location).catch(err =&gt; err)} 结果：加入后亲测有效，确实不再提示这个错误了 2.css设置多行溢出1234单行溢出overflow: hidden;text-overflow:ellipsis;white-space: nowrap; 12345多行溢出display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 3.刷新的方法:123//用的是reload方法window.location.reload()//这种方法不好的方式是会刷新空白,用户体验很不好 4.css鼠标🈲用123pointer-events: none;cursor: default;opacity: 1;//设置透明度 5,get方法与post方法区别 http超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 http方法：HEAD: 与 GET 相同，但只返回 HTTP 报头，不返回文档主体 PUT: 上传指定的 URI 表示 DELETE: 删除指定资源 OPTIONS: 返回服务器支持的 HTTP 方法 CONNECT: 把请求连接转换到透明的 TCP/IP 通道 POST: 向指定的资源提交要被处理的数据 12345// 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2复制代码 GET: 从指定的资源请求数据 GET和POST的区别 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制(2048字符),IE和Safari浏览器限制2k;Opera限制4k;Firefox，Chrome限制8k GET 请求只应当用于取回数据 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 6.js求平面两点之间的距离12345678// 数据可以以数组方式存储，也可以是对象方式let a = {x:'6', y:10}, b = {x: 8, y: 20}; function distant(a,b){ let dx = Number(a.x) - Number(b.x) let dy = Number(a.y) - Number(b.y) return Math.pow(dx*dx + dy*dy, .5) } 7.css禁止用户选择👆12345678body{-webkit-touch-callout: none;-webkit-user-select: none;-khtml-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;} 8.for in 与for of 方法1234567891011121314151617let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2) function find(arr) { for (let num of arr) { console.log(num) } } find(arr)//for of中的num是完整的arr数组中的值let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2) function find(arr) { for (let num in arr) { console.log(num) } } find(arr)//但是for in 中的num相当于下标,只有输出arr[num]才能获得数组中的值 9.数组去重12345678910111213//indexOf()方法 let arr = new Array(1, 2, 3, 5, 6, 3, 1, 1, 2) function find(arr) { let res = [] for (let num of arr) { if (res.indexOf(num) === -1) { res.push(num) } } return res } console.log(find(arr))\\ //1,2,3,5,6 10.如何提高首频加载速度 1.js外联文件放到body底部，css外联文件放到head内2.http静态资源尽量用多个子域名3.服务器端提供html和http静态资源时最好开启gzip4.在js,css,img等资源响应的http headers里设置expires,last-modified5.尽量减少http requests的数量6.js/css/html/img资源压缩7.使用css spirtes，可以减少img请求次数8.大图使用lazyload懒加载9.避免404，减少外联js10.减少cookie大小可以提高获得响应的时间11.减少dom elements的数量12.使用异步脚本，动态创建脚本 11.简述一下你对HTML语义化的理解用正确的标签做正确的事情。 html语义化让页面的内容结构化，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 12.请描述一下 cookies，sessionStorage 和 localStorage 的区别cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 13.css overflow属性overflow 属性规定当内容溢出元素框时发生的事情。 这个属性定义溢出元素内容区的内容会如何处理。如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。 值: visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 让overflow:scroll平滑滚动1-webkit-overflow-scrolling: touch; 14.position中的relative和absolute的定位原点问题absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值 15.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。css .bb{ background-color:red;/_所有识别/ background-color:#00deff\\9; /IE6、7、8识别/ +background-color:#a200ff;/IE6、7识别/ _background-color:#1e0bd1;/IE6识别/ } IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性。 IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 16.css优化,提高性能关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 17.让页面里的字体变清晰，变细用CSS怎么做1-webkit-font-smoothing: antialiased; 18.This对象的理解 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； 19.什么是window对象? 什么是document对象 window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。 20.什么是闭包（closure），为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部 21.如何判断一个对象谁否属于某个类12345678910111213141516171819202122if(a instanceof Person){ alert('yes');}//instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。// 判断对象类型最好的方式// 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。//而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 22.new一个对象的过程1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2、属性和方法被加入到 this 引用的对象中。3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 23.在Vue中的遍历方法v-for控制循环次数的方法1.截取循环的数据 v-for=”(item,index) in domainList.slice(0, 2)” 用这样的方法可以截取循环的数据长度，从而控制循环的次数2.通过v-if来控制 v-for=”(item,index) in domainList” v-if=”index&lt;3” 在标签下紧跟v-if来进行控制，这里是用索引来进行控制的，所以循环的时候记得把index这个参数加到v-for循环中。 24.箭头函数对于箭头函数，this 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。 25.获取接口数据的定义的数组12345678list: { course: { public_assesses: [], course_contents: [], public_collects: [], introduction: '' } }, 在获取数据时，由于接口返回的数据嵌套过多，导致页面渲染报错，在定义数组保存接口数据时，可以定义好要接受的数据的“模版”，或者说把要使用的数据拿出来单独赋值 26.vue-router跳转页面时传参成功但是页面没有刷新12345watch: { '$route' (to, from) { this.$router.go(0) } }, 用watch监听router属性是否有变化，然后决定是否重新刷新页面 27.设置默认显示的子路由12345678910111213141516171819202122232425262728293031323334353637path: '/', component: () =&gt; import('@/views/home_page/index'), name: 'home_page', redirect: 'index_cntent',//用redirect指出默认显示的子路由 children: [{ path: '/about_menu', component: () =&gt; import('@/views/menu/about_menu'), name: 'about_menu' }, { path: '/dervice_menu', component: () =&gt; import('@/views/menu/dervice_menu'), name: 'dervice_menu' }, { path: '/product_menu', component: () =&gt; import('@/views/menu/product_menu'), name: 'product_menu' }, { path: '/service_menu', component: () =&gt; import('@/views/menu/service_menu'), name: 'service_menu' }, { path: '/index_cntent', component: () =&gt; import('@/views/menu/content'), name: 'index_cntent' } ]}, 28关于vue warn的警告解决一般出现 vue warn 的时候一般是vue数据渲染出错，绑定的某个值可能赋值出错，像是给了undefined，或者是原本是图片地址却给了个字符串之类错误，往往导致这方面的错误的时候，提示里一般没有相关文件具体到哪一行那个语法出错，但是会提示了是那个文件，去文件里面逐一排查就好 29.最简单的方式实现前端下载功能（window.location）用window.locatio.href=“xxxx?”+（其他字段）+'&amp;(其他字段)'的方式可以实现打开新的窗口下载文件，前提是后端给返回文件的下载地址，默认打开地址的话像是图片会直接预览 30.textarea禁止拖动,固定宽高1resize: none; 31.控制v-for循环的次数1234561、通过html的标签里面v-if对超出范围的进行隐藏&lt;div v-for=&quot;(item,index) in courselist&quot; v-if=&quot;index &lt; 6&quot; :key='index'&gt;&lt;/div&gt;2、通过sclie截取数组的长度控制循环的次数&lt;div v-for=&quot;(item,index) in courselist.slice(0,6)&quot; :key=&quot;index&quot;&gt;&lt;/div&gt; 32.Cannot read property ‘$createElement’ of undefined12Cannot read property '$createElement' of undefined一般是vue router报出错误,一般是 在写 component 时 写成了 components 33.@click.native12@click.native 是vue在绑定点击事件时用到的指令,因为要给组件加上点击事件,所以要加上.native 子组件内部处理click事件然后向外发送click事件：$emit(&quot;click&quot;.fn) 34.如何用css绘制一个点或者圆形12345678910i { width: 6px; height: 6px; border-radius: 100%; display: inline-block; margin-top: -2px; vertical-align: middle; background: red; margin-right: 8px;} 35.判断一个字符串是不是日期 1234const date = '2020-01-01'if (isNaN(date) &amp;&amp; !isNaN(Date.parse(date))) {console.log(&quot;yes&quot;) }","link":"/2020/12/19/notes/2020/%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9(%E5%9D%91)%F0%9F%90%B1_%F0%9F%91%A4/"}],"tags":[{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"2019","slug":"notes/2019","link":"/categories/notes/2019/"},{"name":"2020","slug":"notes/2020","link":"/categories/notes/2020/"},{"name":"2021","slug":"notes/2021","link":"/categories/notes/2021/"}]}